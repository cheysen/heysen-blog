[{"categories":["Java编程"],"content":"1.基础知识 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:0:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.1 流处理 流是一系列数据项，一次只生成一项。可以想象成汽车组装流水线，尽管流水线实际上是一个序列，但不同加工站的运行一般是并行的。 # 该例子表示把两个文件连接起来创建一个流，然后转换流中的字符，对流中的行进行排序，最后给出流的最后三行。 # 这几个命令在Unix中是同时执行的。 cat file1 file2 | tr \"[a-z]\" \"[A-Z]\" | sort | tail -3 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:1:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.2行为参数化 Stream API是构建在通过传递代码使得操作行为实现参数化的思想上。 比方说，你有一堆发票代码，格式类似于2013UK0001、2014US0002……前四位数代表年份， 接下来两个字母代表国家，最后四位是客户的代码。你可能想按照年份、客户代码，甚至国家来 对发票进行排序。你真正想要的是，能够给sort命令一个参数让用户定义顺序：给sort命令传 递一段独立代码。Java8增加了把代码作为参数传递给另一个方法的能力。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:2:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.3 并行与共享的可变数据 没有共享的可变数据和将方法和函数即代码传递给其他方法的能力是函数式编程范式的基石。函数式编程中的函数的主要意思是“把函数作为一等值”，也即“执行时在元素之间无互动”。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:3:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.4 函数 Java8允许把方法和函数作为一等公民（可传递的值）。让方法作为值构成了其他若干Java8功能的基础。 Java8可以传递方法引用，以前只能传递对象引用 谓词（predicate）：在数学上常常用来代表一个类似函数的东西，他接受一个参数值，并返回true或false。 如果Lambda的长度多于几行，它的行为也不是一目了然的话，应该用方法引用来指向一个有描述性名称的方法，而不是使用匿名的Lambda。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:4:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.5 Stream API与Collection API 用集合循环一个个去迭代再处理元素称为外部迭代，流处理是在库内部进行的，称为内部迭代。 流的并行比使用线程同步更不易出错，流天生具有利用多核的优势。 Collection主要是为了存储和访问数据，而Stream则主要用于描述对数据的计算。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:5:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"1.6 默认方法 设计默认方法的目的在于改变已发布的接口而不破坏已有的实现。例如Java8中List新增的默认方法： default void sort(Comparator\u003c? super E\u003e c) { Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator\u003cE\u003e i = this.listIterator(); for (Object e : a) { i.next(); i.set((E) e); } } 但一个类可以实现多个接口，如果在好几个接口里有多个默认实现，某种程度上意味着Java有了多重继承。Java用一些限制来避免出现类似C++中的菱形继承问题。 2.Lambda表达式 可以把Lambda表达式看做匿名函数，也就是没有声明名称的方法，和匿名类一样可以作为参数传递给一个方法，它有参数列表、函数主体、返回类型、还有可能有可以抛出的异常列表。 // 表达式就是Lambda的返回值 (parameters) -\u003e expression (parameters) -\u003e { statements;} (1).() -\u003e {} (2).() -\u003e \"hello world\" (3).() -\u003e { return \"hello world\";} (4).(Integer i) -\u003e return \"hello\" + i; //无效，不应有return (5).(String s) -\u003e { \"IronMan\"; } //无效，显示返回要加上return ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:6:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"2.1 函数式接口 函数式接口中的抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名成为函数描述符。 任何函数式接口都不允许抛出受检异常。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:7:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"2.2 类型检查、推断和限制 Lambda的类型是从使用Lambda的上下文推断出来的。如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必须与之匹配 **特殊的void兼容规则：**如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:8:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"2.2.1 使用局部变量 Lambda表达式允许使用自由变量（在外层作用域中定义的变量），就像匿名类一样，它们被称作Lambda捕获。Lambda可以没有限制地捕获实例变量和静态变量，但局部变量必须显式声明为final或逻辑上是final的，也就是只能捕获局部变量一次 闭包 闭包是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。但Lambda访问非本地变量有必须是隐式最终的限制，因为局部变量保存在栈上，是线程私有的，线程访问非本地局部变量时实际上是访问它的副本。可以认为Lambda对值封闭，而不是对变量封闭。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:8:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"2.2.2 方法引用 如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。 可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖 指向静态方法的方法引用。Integer::parseInt 指向任意类型实例方法的方法引用。String::length 指向现有对象的实例方法的方法引用。在 Lambda 中 调 用 一 个 已 经 存 在 的 外 部 对 象 中 的 方 法 。 例 如 ， Lambda 表 达 式 ()-\u003eexpensiveTransaction.getValue()可以写作expensiveTransaction::getValue ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:8:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"2.2.3 复合 // 1.比较器链。如先按重量递减排序，两个苹果一样重时，再按国家排序 inventory.sort(comparing(Apple::getWeoght)) .reversed() .thenComparing(Apple::getCountry) // 2.谓词复合。and和or是按照在表达式链中的位置从左向右确定优先级的。a.or(b).and(c)可以看做(a || b) \u0026\u0026 c Predicate\u003cApple\u003e redAndHeavyAppleOrGreen = redApple.and(a -\u003e a.getWeight() \u003e 150) .or(a -\u003e \"green\".equals(a.getColor())); // 3.函数复合。 Function\u003cInteger, Integer\u003e f = x -\u003e x + 1; Function\u003cInteger, Integer\u003e g = x -\u003e x * 2; Function\u003cInteger, Integer\u003e h = f.andThen(g); //数学上写作g(f(x)) Function\u003cInteger, Integer\u003e h = f.compose(g); //数学上写作f(g(x)) int result = h.apply(1); 3.引入流 流：从支持数据处理操作的源生成的元素序列。流只能消费一次且是按需计算的。 元素序列：访问特定元素类型的一组有序值 ，集合讲的是数据，流讲的是计算 。 源：从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 数据处理操作：流操作可以顺序执行，也可并行执行 。 流水线：很多流操作本身会返回一个流 ，流水线的操作可以看作对数据源进行数据库式查询。 内部迭代：流的迭代操作是在背后进行的。 Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:8:3","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"3.1 流操作 可以连接起来的流操作称为中间操作，关闭流的操作称为操作。 流的流水线理念类似于建造者模式。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:9:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"3.1.1 中间操作 中间操作会返回另一个流。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理，因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:9:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"3.1.2 终端操作 终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、 Integer，甚至void。 4.使用流 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:9:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.1 筛选和切片 filter ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:10:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.2 映射 map、flatMap ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:11:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.3 查找和匹配 allMatch、anyMatch、noneMatch、findFirst、findAny ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:12:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.4 归约 reduce 归约方法的优势与并行化 相比于逐步迭代，使用reduce的好处在于，这里的迭代被内部迭代抽象化了，这让内部实现得以选择并行执行reduce操作。而迭代式求和例子要更新共享变量sum，这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争消了并行本应带来的 性能提升。这种计算的并行化需要另一种办法法：将输入分块，分块求和，最后合并起来。但这样的代码看起来就完全不一样了。但要并行执行需要代价，传递给reduce的Lambda不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:13:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.5 原始类型流特化 为了避免拆装箱操作带来的性能损耗，Java8引入了三个原始类型特化流接口（Optional也有）来解决这个问题：IntStream、DoubleStream和LongStream。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:14:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"4.6 创建流 //由值创建流 Stream\u003cString\u003e stream = Stream.of(\"Java 8 \", \"Lambdas \", \"In \", \"Action\"); Stream\u003cString\u003e emptyStream = Stream.empty(); //由数组创建流 int[] numbers = {2, 3, 5, 7, 11, 13}; int sum = Arrays.stream(numbers).sum(); //由函数生成流 Stream.iterate(new int[]{0, 1},t -\u003e new int[]{t[1],t[0] + t[1]}) .limit(10) .map(t -\u003e t[0]) .forEach(System.out::println); // ===相比于iterate，generate是有状态的 IntSupplier fib = new IntSupplier(){ private int previous = 0; private int current = 1; public int getAsInt(){ int oldPrevious = this.previous; int nextValue = this.previous + this.current; this.previous = this.current; this.current = nextValue; return oldPrevious; } }; IntStream.generate(fib).limit(10).forEach(System.out::println); //===== 5.用流收集数据 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:15:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.1 Collectors预定义收集器 Collectors.counting计数 Collectors.max(min)By 查找最大值和最小值 Collectors.summingInt，Collectors.averagingInt(Long|Double)汇总 Collectors.summarizingInt(Long|Double)一次性取总和、平均值、最大值和最小值 Collectors.joining(可选分隔符)连接字符串 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:16:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.2 广义的归约汇总 Collectors.reducing：把流中的第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。注意可能会返回null。 收集与归约 reduce方法旨在把两个值结合起来生成一个新值，是一个不可变的归约。collect是改变容器从而累积要输出的结果。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:17:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.3 分组 一级分组。groupingBy(f)，f是分类函数实际上是groupingBy(f, toList())的简便写法 n级分组，可以将collector类型传递给前一个groupingBy的第二个参数，以此类推。 按子组收集数据，groupingBy的第二个收集器可以是任何类型 把收集器的结果转换为另一种类型。Collectors.collectingAndThen mapping ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:18:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.4 分区 partitioningBy分区是分组的特殊情况，由一个谓词作为分类函数，他称为分区函数。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:19:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5 收集器接口 package java.util.stream; import java.util.Collections; import java.util.EnumSet; import java.util.Objects; import java.util.Set; import java.util.function.BiConsumer; import java.util.function.BinaryOperator; import java.util.function.Function; import java.util.function.Supplier; // A compilation test for the code snippets in this class-level javadoc can be found at: // test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java // The test needs to be updated if the examples in this javadoc change or new examples are added. /** * A \u003ca href=\"package-summary.html#Reduction\"\u003emutable reduction operation\u003c/a\u003e that * accumulates input elements into a mutable result container, optionally transforming * the accumulated result into a final representation after all input elements * have been processed. Reduction operations can be performed either sequentially * or in parallel. * * \u003cp\u003eExamples of mutable reduction operations include: * accumulating elements into a {@code Collection}; concatenating * strings using a {@code StringBuilder}; computing summary information about * elements such as sum, min, max, or average; computing \"pivot table\" summaries * such as \"maximum valued transaction by seller\", etc. The class {@link Collectors} * provides implementations of many common mutable reductions. * * \u003cp\u003eA {@code Collector} is specified by four functions that work together to * accumulate entries into a mutable result container, and optionally perform * a final transform on the result. They are: \u003cul\u003e * \u003cli\u003ecreation of a new result container ({@link #supplier()})\u003c/li\u003e * \u003cli\u003eincorporating a new data element into a result container ({@link #accumulator()})\u003c/li\u003e * \u003cli\u003ecombining two result containers into one ({@link #combiner()})\u003c/li\u003e * \u003cli\u003eperforming an optional final transform on the container ({@link #finisher()})\u003c/li\u003e * \u003c/ul\u003e * * \u003cp\u003eCollectors also have a set of characteristics, such as * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a * reduction implementation to provide better performance. * * \u003cp\u003eA sequential implementation of a reduction using a collector would * create a single result container using the supplier function, and invoke the * accumulator function once for each input element. A parallel implementation * would partition the input, create a result container for each partition, * accumulate the contents of each partition into a subresult for that partition, * and then use the combiner function to merge the subresults into a combined * result. * * \u003cp\u003eTo ensure that sequential and parallel executions produce equivalent * results, the collector functions must satisfy an \u003cem\u003eidentity\u003c/em\u003e and an * \u003ca href=\"package-summary.html#Associativity\"\u003eassociativity\u003c/a\u003e constraints. * * \u003cp\u003eThe identity constraint says that for any partially accumulated result, * combining it with an empty result container must produce an equivalent * result. That is, for a partially accumulated result {@code a} that is the * result of any series of accumulator and combiner invocations, {@code a} must * be equivalent to {@code combiner.apply(a, supplier.get())}. * * \u003cp\u003eThe associativity constraint says that splitting the computation must * produce an equivalent result. That is, for any input elements {@code t1} * and {@code t2}, the results {@code r1} and {@code r2} in the computation * below must be equivalent: * \u003cpre\u003e{@code * A a1 = supplier.get(); * accumulator.accept(a1, t1); * accumulator.accept(a1, t2); * R r1 = finisher.apply(a1); // result without splitting * * A a2 = supplier.get(); * accumulator.accept(a2, t1); * A a3 = supplier.get(); * accumulator.accept(a3, t2); * R r2 = finisher.apply(combiner.apply(a2, a3)); // result with splitting * } \u003c/pre\u003e * * \u003cp\u003eFor collectors that do not have the {@code UNORDERED} characteristic, * two accumulated results {@code a1} and {@code a2} are equivalent if * {@code finisher.apply(a1).equals(finisher.apply(a2))}. For unordered * collectors, equiv","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.1 supplier建立新的结果容器 该方法返回一个结果为空的supplier，也就是一个无参函数，在调用是它会创建一个空的累加器实例，供数据收集过程使用，所以，在对空流执行操作的时候，这个空的累加器也代表了收集过程的结果。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.2 accumulator将元素添加到结果容器 该方法返回执行归约操作的函数。该函数返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现便利元素的效果。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.3 finisher对结果容器应用最终转换 该方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。如果结果无需转换，则只需返回identity函数 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:3","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.4 combiner合并两个结果容器 该方法返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。对于toList而言：只是简单的把从流的第二个部分收集到的项目列表添加到遍历第一部分时得到的列表后面 public static \u003cT\u003e Collector\u003cT, ?, List\u003cT\u003e\u003e toList() { return new CollectorImpl\u003c\u003e((Supplier\u003cList\u003cT\u003e\u003e) ArrayList::new, List::add, (left, right) -\u003e { left.addAll(right); return left; },CH_ID); } 该方法会用到Java7中引入的分支/合并框架和Spliterator抽象。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:4","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.5 characteristics方法 该方法可以提示流是否可以进行归约以及可使用的优化。 UNORDERED–归约结果不受流中项目的遍历和累积顺序的影响 CONCUNRRENT–accumulator函数可以从多个线程同时调用，且收集器可以并行归约流，如果收集器没有标为UNORDERED，它仅在用于无序数据源时才可以进行归约 IDENTITY_FINISH–这表明完成器方法返回的函数是一个恒等函数，可以跳过。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:5","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"5.5.6 自定义收集 对于IDENTITY_FINISH的收集操作，Stream有一个重载的collect方法接受三个函数（supplier,accumulator,combiner）。我们也可以通过实现collector接口定义自己的收集器。 6.并行数据处理与性能 Stream的并行流内部使用流Fork/Join框架。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:20:6","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.1 将顺序流转换为并行流 parallel会将顺序流转化为并行流。但这不代表流本身发生了变化，只是在内部设置流一个boolean标志，表示在调用该方法后的所有操作都并行执行。同样的，可以用sequential方法把流变为顺序流，但是如果将这个两个方法结合时，会以最后一次调用的为准。 配置并行流使用的线程池 并行流内部使用流默认的ForkJoinPool，它默认的线程数量就是处理器数量，由Runtime.getRuntime().availableProcessors()获取(实际返回的是可用内核的数量，包括超线程生成的虚拟内核)。 但是也可以自定义System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\",\"数量\")，注意这是一个全局设置，它将影响所有并行流。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:21:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.2 正确使用并行 import java.util.stream.*; public class ParallelStreams { public static long iterativeSum(long n) { long result = 0; for (long i = 0; i \u003c= n; i++) { result += i; } return result; } public static long sequentialSum(long n) { return Stream.iterate(1L, i -\u003e i + 1).limit(n).reduce(Long::sum).get(); } public static long parallelSum(long n) { return Stream.iterate(1L, i -\u003e i + 1).limit(n).parallel().reduce(Long::sum).get(); } public static long rangedSum(long n) { return LongStream.rangeClosed(1, n).reduce(Long::sum).getAsLong(); } public static long parallelRangedSum(long n) { return LongStream.rangeClosed(1, n).parallel().reduce(Long::sum).getAsLong(); } public static long sideEffectSum(long n) { Accumulator accumulator = new Accumulator(); LongStream.rangeClosed(1, n).forEach(accumulator::add); return accumulator.total; } public static long sideEffectParallelSum(long n) { Accumulator accumulator = new Accumulator(); LongStream.rangeClosed(1, n).parallel().forEach(accumulator::add); return accumulator.total; } public static class Accumulator { private long total = 0; public void add(long value) { total += value; } } } package chl; //=============================================================================================== import java.util.function.Function; public class MyParallelStreams { public static long measureSumPerf(Function\u003cLong, Long\u003e adder, long n) { long fastest = Long.MAX_VALUE; for (int i = 0; i \u003c 10; i++) { long start = System.nanoTime(); long sum = adder.apply(n); long duration = (System.nanoTime() - start) / 1000000; System.out.println(\"Result:\" + sum); if (duration \u003c fastest) fastest = duration; } return fastest; } public static void main(String[] args) { System.out.println(\"耗时:\" + measureSumPerf(ParallelStreams::sideEffectParallelSum, 10000000)); } } 要确保并行正确执行必须保证不存在共享的可变状态。 测量。有时候并行流并不一定比顺序流快。 注意装箱。自动装箱和拆箱操作会大大降低性能，这时候可以使用原始类型流。 有些操作在并行流上的性能比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作。如果不依赖顺序，可以调用unordered方法把有序流变成无序流。 如果一个元素通过流水线的处理成本高，那么使用并行流时性能好的可能性比较大。 对于较小的数据量，选择并行流并不的优先级并不高，因为并行化（分配线程等资源）的开销更高。 考虑流背后的数据结构是否易于分解。可以自定义Spliterator来控制分解过程。 流自身的特点以及流水线中的中间操作修改流的方法，都可能会改变分解过程的性能。一个已知大小的流比未知的更好拆分。 还要考虑终端操作中合并步骤的代价是大是小，如果这一步代价很大，那么组合每个子流的部分结果所产生的的代价就可能会超出通过并行流得到的性能提升。 流的数据源可分解性 源 可分解性 ArrayList 极佳 LinkedList 差 IntStream.range 极佳 Stream.iterate 差 HashSet 好 TreeSet 好 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:22:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.3 Fork/Join框架 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:23:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.3.1 RecursiveTask public abstract class RecursiveTask\u003cV\u003e extends ForkJoinTask\u003cV\u003e { private static final long serialVersionUID = 5232453952276485270L; @SuppressWarnings(\"serial\") V result; protected abstract V compute(); public final V getRawResult() { return result; } protected final void setRawResult(V value) { result = value; } protected final boolean exec() { result = compute(); return true; } } 使用多个ForkJoinPool是没有意义的，一般把它实例化一次，然后把实例保存在静态字段中，使之称为单例，这样就可以重用。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:23:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.3.2 使用Fork/Join的最佳做法 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，应始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。 对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低。这样做可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。 调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面看栈跟踪（ stack trace）来找问题，但放在分支合并计算上就不行了，因为调用compute的线程并不是概念上的调用方，后者是调用fork的那个。 和并行流一样，不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长；一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优势（例如执行代码分析——删去从未被使用的计算） ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:23:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.3.3 工作窃取 应该让划分的子任务都用相同的时间完成，但是由于外部因素，如划分策略效率低、磁盘访问慢或是需要和外部服务协调执行，每个子任务所花的时间不尽相同。框架使用一种称为工作窃取（work stealing）的技术解决这个问题。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:23:3","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.4 Spliterator可分迭代器 public interace Spliterator\u003cT\u003e { /** * 按序遍历，如果没有元素则返回false，否则对元素执行给定的操作并返回true */ boolean tryAdvance(Consumer\u003c? super T\u003e action); /** * 把元素划出去分给第二个Spliterator,让他们并行处理，直到返回null */ Spliterator\u003cT\u003e trySplit(); /** * 返回forEachRemaining遍历将遇到的估计值，如果无限或无法计算，则返回Long.MAX_VALUE */ long estimateSize(); int characteristics(); } ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:24:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.4.1 拆分过程 Spliterator的特性 特性 含义 ORDERED 元素有既定顺序，Spliterator在遍历和划分时遵循这一顺序 DISTINCT 对于任意一对遍历过的元素x和y，x.equals(y)返回false SORTED 遍历的元素按照一个预定义的顺序排序 SIZED 该Spliterator由一个已知大小的源建立，因此estimatedSize()返回的是准确值 NONNULL 保证遍历的元素不会为null IMMUTABLE 数据源不能修改 CONCURRENT 数据源可被其他线程同时修改而无需同步 SUBSIZED 所有拆分出来的Spliterator都是SIZED ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:24:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"6.4.2 自定义Spliterator 7. 重构、测试和调试 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:24:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.1 重构 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:25:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.1.1 使用Lambda替换匿名类 需要注意的是，Lambda中的this和super代表的是包含类，而匿名类的代表匿名类自身；匿名类可以屏蔽包含类的变量，而Lambda不能。另外，在涉及重载的上下文中，应该使用显示的类型转换来减低类型推断的难度。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:25:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.1.2 方法引用代替Lambda ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:25:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.1.3 从命令式的数据处理切换到Stream ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:25:3","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.1.4重构模式 有条件的延迟执行 if (logger.isLoggable(Log.FINER)){ logger.finer(\"Problem: \" + generateDiagnostic()); } //使用log方法代替上面的判断 public void log(Level level, Supplier\u003cString\u003e msgSupplier) 如果需要频繁地从客户端去查询一个对象的状态（比如日志器的状态），只是为了传递参数、调用该对象的一个方法（比如输出一条日志），那么可以考虑实现一个新的方法，以Lambda或者方法表达式作为参数，代码会更易读，封装性会更好（对象的状态也不会暴露给客户端代码了）。 环绕执行 Lambda作为参数传递，类似切面。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:25:4","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2 使用Lambda重构面向对象的设计模式 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2.1 策略模式 关键点：实现函数式接口 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2.2 模板方法 关键点：方法增加函数式入参 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2.3 观察者模式 关键点：Lambda代替通知方法，注意如果观察者的逻辑十分复杂，比如它们可能持有状态亦或是定义了多个方法等，则应继续使用类的方式。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:3","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2.4 责任链模式 关键点：UnaryOperator、andThen ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:4","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2.5 工厂模式 关键点：构造函数入参低于2个时，使用方法引用… ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:26:5","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.2 测试Lambda ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:27:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"7.3 调试 peek方法？ 8.默认方法 不同类型兼容性：二进制、源代码、和函数行为 二进制兼容：现有的二进制执行文件能无缝链（包括验证、准备和解析）和运行。比如，为接口添加一个方法就是二进制兼容的，这种方式下，如果新加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。 源代码兼容：引入变化后，现有的程序依然能成功编译通过。 函数行为兼容：变更后，程序接受同样的输入能得到同样的结果。 解决菱形继承的三条规则 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级 如果第一条无法判断，那么子接口的优先级更高。函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体 如果还是无法判断，继承了多个接口的类必须通过显示覆盖和调用期望的方法 Java8引入了一种新语法X.super.m(...)，其中X是希望调用的m方法所在的父接口。 9.Optional 使用Optional的语义在于：可以很清楚地知道它可以接受空值，或者它可能返回一个空值。 Optional.empty(); Optional.of(...); Optional.ofNullable(...); //如果要处理的元素为空，则不做任何操作,并返回一个空的Optional对象 Optional.map(...); Optional.flatMap(...); Optional不能被序列化。Java语言的架构师明确地说过它的设计初衷仅仅是要支持能返回Optional对象的语法。 Optional.get(); Optional.orElse(T other); Optional.orElseGet(Supplier\u003c? extends T\u003e other); Optional.orElseThrow(Supplier\u003c? extends X\u003e exceptionSupplier); Optional.ifPresent(Consumer\u003c? super T\u003e); Optional.isPresent(); 10.CompletableFuture组合式异步编程 相比于并行流，CompletableFuture的优势在于可以配置线程池中的线程大小。 如果进行的是计算密集型的操作，并且没有I/O，推荐使用Stream接口。 如果并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好。 11.新的日期API ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:28:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.1 LocalDate和LocalTime ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:29:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.2 Instant 为了便于机器使用而设计 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:30:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.3 Duration或Period Duration主要用于以秒和纳秒衡量时间的长短；Period可以以年、月或日的方式对多个时间单位建模。 方法名 是否静态方法 描述 between 是 创建两个时间点之间的 interval (间隔) from 是 由一个临时时间点创建 interval of 是 由它的组成部分创建 interval 的实例 parse 是 由字符串创建 interval 的实例 addTo 否 创建该 interval 的副本，并将其Ԯ加到某个指定的 temporal 对象 get 否 读取该 interval 的状态 isNegative 否 检查该 interval 是否为负值，不包含零 isZero 否 检查该 interval 的时长是否为零 minus 否 通过减去一定的时间创建该 interval 的副本 multipliedBy 否 将 interval 的值乘以某个标量创建该 interval 的副本 negated 否 以忽略某个时长的方式创建该 interval 的副本 plus 否 以增加某个指定的时长的方式创建该 interval 的副本 subtractFrom 否 从指定的 temporal 对象中减去该 interval ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:31:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.4 操纵、解析和格式化日期 LocalDate date1 = LocalDate.of(2014, 3, 18); LocalDate date2 = date1.withYear(2011); LocalDate date3 = date2.withDayOfMonth(25); LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9); LocalDate date1 = LocalDate.of(2014, 3, 18); LocalDate date2 = date1.plusWeeks(1); LocalDate date3 = date2.minusYears(3); LocalDate date4 = date3.plus(6, ChronoUnit.MONTHS); 方法名 是否静态方法 描述 from 是 依据传入的 Temporal 对象创建对象实例 now 是 依据系统时钟创建 Temporal 对象 of 是 由 Temporal 对象的某个部分创建该对象的实例 parse 是 由字符串创建 Temporal 对象的实例 atOffset 否 将 Temporal 对象和某个时区偏移相结合 atZone 否 将 Temporal 对象和某个时区相结合 format 否 使用某个指定的格式器将Temporal对象转换为字符串（ Instant类不提供该方法） get 否 读取 Temporal 对象的某一部分的值 minus 否 创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值ђ去一定的时长，创建该副本 plus 否 创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值加上一定的时长，创建该副本 with 否 以该 Temporal 对象为模板，对某些状态进行修改创建该对象的副本 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:32:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.4.1 使用TemporalAdjuster 可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更 加 灵 活 地 处 理 日 期 。 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:32:1","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.4.2 DateTimeFormatter 线程安全的，内置了几种解析常量。 LocalDate date = LocalDate.of(2014, 3, 18); String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); // 20140318 String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2014-03-18 LocalDate date1 = LocalDate.parse(\"20140318\",DateTimeFormatter.BASIC_ISO_DATE); LocalDate date2 = LocalDate.parse(\"2014-03-18\",DateTimeFormatter.ISO_LOCAL_DATE); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\"); LocalDate date1 = LocalDate.of(2014, 3, 18); String formattedDate = date1.format(formatter); LocalDate date2 = LocalDate.parse(formattedDate, formatter); 创建一个本地化的DateTimeFormatter DateTimeFormatter italianFormatter =DateTimeFormatter.ofPattern(\"d. MMMM yyyy\", Locale.ITALIAN); LocalDate date1 = LocalDate.of(2014, 3, 18); String formattedDate = date.format(italianFormatter); // 18. marzo 2014 LocalDate date2 = LocalDate.parse(formattedDate, italianFormatter); 如果需要更加细粒度的控制， DateTimeFormatterBuilder类还提供了更复杂的格式器，可以选择恰当的方法，一步一步地构造自己的格式器。另外，它还提供了非常强大的解析功能，比如区分大小写的解析、柔性解析（允许解析器使用启发式的机制去解析输入，不精 确 地 匹 配 指 定 的 模 式 ）、 填充 ， 以 及 在 格 式 器 中 指 定 可 选 节 。 DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder() .appendText(ChronoField.DAY_OF_MONTH) .appendLiteral(\". \") .appendText(ChronoField.MONTH_OF_YEAR) .appendLiteral(\" \") .appendText(ChronoField.YEAR) .parseCaseInsensitive() .toFormatter(Locale.ITALIAN); ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:32:2","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"11.5 处理不同的时区和历法 ","date":"2025-04-16","objectID":"/java8%E5%AE%9E%E6%88%98/:33:0","tags":["Java基础"],"title":"Java8实战","uri":"/java8%E5%AE%9E%E6%88%98/"},{"categories":["Java编程"],"content":"概述 泛型可以使得在编译期发现bug,从而增加代码稳定性。泛型使得在定义类、接口和方法时类型（类和接口）可以被参数化。就像方法声明中使用的形参，类型参数对于不同的输入可以重用代码。不同点在于形参的输入是值，类型参数的输入是类型。 使用泛型有诸多益处： 编译器强类型检查：Java编译器对泛型代码运行强类型检查，如果代码类型不安全则报错。修复编译器错误总比修复运行时错误简单 消除转换： 下面代码端需要转换 List list = new ArrayList(); list.add(\"hello\"); String s = (String) list.get(0); 使用泛型则不需要转换 List\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"hello\"); String s = list.get(0); // no cast 提供实现通用算法的能力:通过泛型,程序员能实现集合上不同类型的通用算法,这些算法可以自定义,类型安全且更易读 泛型类型 泛型类型是类型参数化的泛型类或泛型接口。 以一个示例展示泛型的使用，下面非泛型的Box类适用于任何类型的对象 public class Box { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; } } 因为它的方法接受或返回一个Object对象,所以你可以传入除原始类型外的任何对象。但在运行时无法验证该类如何被使用。一部分代码可能使用Integer并期望输出Integer，同时另一部分代码可能错误地传入String,这将导致运行时错误。 泛型类的定义格式如下： class name\u003cT1, T2, ..., Tn\u003e { /* ... */ } 将泛型应用到Box类上 /** * Generic version of the Box class. * @param \u003cT\u003e the type of the value being boxed */ public class Box\u003cT\u003e { // T stands for \"Type\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 类型变量可以是任何非原始类型:任意类、接口、数组甚至是其它类型变量。 类型参数命名约定 约定类型参数命名是单个大写字母，常见的类型参数名称如下： E-Element(在Java集合框架中常用) K-Key N-Number T-Type V-Value S,U,V等 调用并实例化泛型类型 要使用泛型类,必须以具体的类型值代替泛型定义。如使用Box类Box\u003cInteger\u003e integerBox;可以把泛型类调用类比普通方法调用,只不过传递的是类型参数（就像上面传递的是Integer）。 type paramaeter与type argument术语: 编码时,type argument用来创建一个参数化的类型。如Foo\u003cT\u003e中的T是type paramaeter，Foo\u003cString\u003e中的String是type argument 泛型类型的调用也叫类型参数化。泛型类的实例化如下例子: Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); //java 7之后,编译器可以从上下文中确定或推断类型参数 Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); 多类型参数 public interface Pair\u003cK, V\u003e { public K getKey(); public V getValue(); } public class OrderedPair\u003cK, V\u003e implements Pair\u003cK, V\u003e { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } OrderedPair\u003cString, Integer\u003e p1 = new OrderedPair\u003c\u003e(\"Even\", 8);//自动装箱使得可以传入原始类型 OrderedPair\u003cString, String\u003e p2 = new OrderedPair\u003c\u003e(\"hello\", \"world\"); 参数化类型 可以将类型参数(如K,V)替换为参数化类型(如List\u003cString\u003e) OrderedPair\u003cString, Box\u003cInteger\u003e\u003e p = new OrderedPair\u003c\u003e(\"primes\", new Box\u003cInteger\u003e(...)); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:0:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"原始类型 原始类型是不带任何类型参数的泛型类或泛型接口。 public class Box\u003cT\u003e { public void set(T t) { /* ... */ } // ... } //参数化定义 Box\u003cInteger\u003e intBox = new Box\u003c\u003e(); //Box\u003cT\u003e的原始类型 Box rawBox = new Box(); Box是Box\u003cT\u003e的原始类型,但是非泛型类或接口不是原始类型。 原始类型在旧版代码中出现，因为那是许多API类（像Collections）不支持泛型。当使用原始类型时，实际上是一种预泛型行为:Box的f泛型参数被参数化为Object。为了向后兼容，将参数化类型赋值给原始类型是允许的： Box\u003cString\u003e stringBox = new Box\u003c\u003e(); Box rawBox = stringBox; // OK 但是反过来你会得到一个警告: Box rawBox = new Box(); // rawBox is a raw type of Box\u003cT\u003e Box\u003cInteger\u003e intBox = rawBox; // warning: unchecked conversion 如果你用原始类型来调用泛型类的方法同样会得到警告: //这段代码不会报错,stringBox在运行时存储的值为\u003cInteger\u003e类型 Box\u003cString\u003e stringBox = new Box\u003c\u003e(); Box rawBox = stringBox; rawBox.set(8); // warning: unchecked invocation to set(T) 这表明原始类型绕过了泛型类型检查 未受检错误信息 当在旧版本代码中使用泛型代码时,可能出现以下警告信息: Note: Example.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 这通常在旧版API中使用原始类型时出现： public class WarningDemo { public static void main(String[] args){ Box\u003cInteger\u003e bi; bi = createBox(); } static Box createBox(){ return new Box(); } } “unchecked\"意味着编译器没有足够的类型信息执行所有的类型检查来确保类型安全。使用-Xlint:unchecked重新编译来查看所有'“unchecked\"警告： WarningDemo.java:4: warning: [unchecked] unchecked conversion found : Box required: Box\u003cjava.lang.Integer\u003e bi = createBox(); ^ 1 warning 可以用-Xlint:-unchecked禁用未受检警告；@SuppressWarnings(\"unchecked\")注解会抑制未受检警告。 泛型方法 泛型方法是引入自己的类型参数的方法。与声明泛型类型相似，但是其类型参数的作用域限制在方法内。静态、非静态泛型方法以及泛型类构造器都合法。 泛型方法的语法包含出现在方法返回类型前的类型参数列表。 public class Util { public static \u003cK, V\u003e boolean compare(Pair\u003cK, V\u003e p1, Pair\u003cK, V\u003e p2) { return p1.getKey().equals(p2.getKey()) \u0026\u0026 p1.getValue().equals(p2.getValue()); } } public class Pair\u003cK, V\u003e { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } 泛型方法的调用如下: Pair\u003cInteger, String\u003e p1 = new Pair\u003c\u003e(1, \"apple\"); Pair\u003cInteger, String\u003e p2 = new Pair\u003c\u003e(2, \"pear\"); boolean same = Util.\u003cInteger, String\u003ecompare(p1, p2); 当省略明确的类型时,编译器将推断具体的类型: Pair\u003cInteger, String\u003e p1 = new Pair\u003c\u003e(1, \"apple\"); Pair\u003cInteger, String\u003e p2 = new Pair\u003c\u003e(2, \"pear\"); boolean same = Util.compare(p1, p2); 边界类型参数 如果我们想限制作为类型参数的参数化类型,如一个针对数字操作的方法仅接受Number及其子类,可以使用有界类型参数。 要声明有界类型参数，列出类型参数名称，后面加上extends关键字，然后是它的上界。在这种情况下，extends是广义的意味着\"extends(类)“或\"implements(接口)\"。 public class Box\u003cT\u003e { private T t; public void set(T t) { this.t = t; } public T get() { return t; } public \u003cU extends Number\u003e void inspect(U u){ System.out.println(\"T: \" + t.getClass().getName()); System.out.println(\"U: \" + u.getClass().getName()); } public static void main(String[] args) { Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); integerBox.set(new Integer(10)); //使用了有界泛型参数,编译器失败 integerBox.inspect(\"some text\"); // error: this is still String! } } 有界泛型参数除了限制类型外,你还可以用起实例调用边界类型的方法: public class NaturalNumber\u003cT extends Integer\u003e { private T n; public NaturalNumber(T n) { this.n = n; } public boolean isEven() { return n.intValue() % 2 == 0; } // ... } 多边界 一个类型参数可以有多个边界: \u003cT extends B1 \u0026 B2 \u0026 B3\u003e 有多个边界的类型变量是所有边界类型的子类型。如果有一个边界是类，它必须先声明(否则编译不通过)，例如： Class A { /* ... */ } interface B { /* ... */ } interface C { /* ... */ } class D \u003cT extends A \u0026 B \u0026 C\u003e { /* ... */ } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:1:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的边界类型参数 有界类型参数是实现泛型算法的关键。下面的泛型使用会出现编译错误： public static \u003cT\u003e int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e \u003e elem) // compiler error ++count; return count; } 因为”\u003e“操作符只能运用于原始类型,可以使用以Comparable\u003cT\u003e为上界的类型参数修复: public static \u003cT extends Comparable\u003cT\u003e\u003e int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) \u003e 0) ++count; return count; } 泛型中的继承和子类型 把一种类型的对象赋值给另一种类型的对象在某些情况下是可行的。例如，你可以把Integer的对象赋值给Object的，因为Object是Integer的超类： Object someObject = new Object(); Integer someInteger = new Integer(10); someObject = someInteger; // OK 因为Integer也是Number的子类型,所以以下代码也合法: public void someMethod(Number n) { /* ... */ } someMethod(new Integer(10)); // OK someMethod(new Double(10.1)); // OK 泛型也适用以上的赋值法则: Box\u003cNumber\u003e box = new Box\u003cNumber\u003e(); box.add(new Integer(10)); // OK box.add(new Double(10.1)); // OK 考虑以下代码: public void boxTest(Box\u003cNumber\u003e n) { /* ... */ } 该方法不能接受Box\u003cInteger\u003e或Box\u003cDouble\u003e为入参,因为它们都不是Box\u003cNumber\u003e的子类型。 给定类型A和B，MyClass\u003cA\u003e和MyClass\u003cB\u003e没有从属关系,它们的父类都是Object。 泛型类和其子类 你可以通过继承或实现来子类化一个泛型类或接口。 以Collections类举例,ArrayList\u003cE\u003e实现List\u003cE\u003e,List\u003cE\u003e继承Collection\u003cE\u003e。 自定义一个list接口PayloadList: interface PayloadList\u003cE,P\u003e extends List\u003cE\u003e { void setPayload(int index, P val); ... } 下列参数化的PayloadList是List\u003cString\u003e的子类型: PayloadList\u003cString,String\u003e PayloadList\u003cString,Integer\u003e PayloadList\u003cString,Exception\u003e 类型推断 类型推断是Java编译器确定具体的类型参数来使方法调用和声明可用的能力。类型推断算法确定参数的类型，该类型赋值给返回值或直接返回。最后，推断算法找到适用于所有参数的最合适的类型。 下面的例子，推断确定了传递给pick方法的两个参数是Serializable类型。 static \u003cT\u003e T pick(T a1, T a2) { return a2; } Serializable s = pick(\"d\", new ArrayList\u003cString\u003e()); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:2:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的类型推断 类型推断可以让你像调用普通方法一样调用泛型方法。看看下面的例子： public class BoxDemo { public static \u003cU\u003e void addBox(U u, java.util.List\u003cBox\u003cU\u003e\u003e boxes) { Box\u003cU\u003e box = new Box\u003c\u003e(); box.set(u); boxes.add(box); } public static \u003cU\u003e void outputBoxes(java.util.List\u003cBox\u003cU\u003e\u003e boxes) { int counter = 0; for (Box\u003cU\u003e box: boxes) { U boxContents = box.get(); System.out.println(\"Box #\" + counter + \" contains [\" + boxContents.toString() + \"]\"); counter++; } } public static void main(String[] args) { java.util.ArrayList\u003cBox\u003cInteger\u003e\u003e listOfIntegerBoxes = new java.util.ArrayList\u003c\u003e(); BoxDemo.\u003cInteger\u003eaddBox(Integer.valueOf(10), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes); BoxDemo.outputBoxes(listOfIntegerBoxes); } } //输出 Box #0 contains [10] Box #1 contains [20] Box #2 contains [30] addBox方法定义了一个名为U的类型参数,通常Java编译器能推断调用的泛型方法的类型参数。所以多数情况下不用具体说明。例如，调用addBox方法,你可以使用具体的类型参数: BoxDemo.\u003cInteger\u003eaddBox(Integer.valueOf(10), listOfIntegerBoxes); 相应的,如果你省略类型参数,Java编译器从方法参数中自动推断类型参数的类型为Integer: BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"实例化泛型类中的类型推断 泛型类实例化时,你可以在实例化的\u003c\u003e符号中省略类型参数,但是你不能省略\u003c\u003e符号,否则会被认为是原始类型: Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap\u003cString, List\u003cString\u003e\u003e(); //省略类型参数 Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap\u003c\u003e(); //未受检警告 Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap(); // unchecked conversion warning ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:4:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型构造器中的类型推断 泛型构造器可以存在于泛型类和非泛型类中，泛型构造器可以有自己的形式类型参数。如： class MyClass\u003cX\u003e { \u003cT\u003e MyClass(T t) { // ... } } 考虑下面MyClass的实例化: MyClass\u003cInteger\u003e myObject1 = new MyClass\u003cInteger\u003e(\"\") //省略版 MyClass\u003cInteger\u003e myObject2 = new MyClass\u003c\u003e(\"\"); 该语句定义了参数化类型的MyClass\u003cInteger\u003e,它表明类型参数X的类型是Integer。同时，编译器推断类型参数T的类型是String。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:5:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"目标类型 Java编译器利用目标输入来判断泛型方法调用的类型参数。表达式的目标类型是Java编译器期望的数据类型，具体取决于表达式出现的位置。考虑Collections.emptyList方法，其定义如下： static \u003cT\u003e List\u003cT\u003e emptyList(); 考虑下面的赋值语句: List\u003cString\u003e listOne = Collections.emptyList(); 该表达式期望一个List\u003cString\u003e的实例,这种数据类型是目标类型。因为emptyList方法返回List\u003cT\u003e,编译器推断类型参数T必须是String。这在Java7和Java8中都适用。 但以下例子存在不同： void processStringList(List\u003cString\u003e stringList) { // process stringList } //这在Java7中无法编译,因为List\u003cT\u003e在Java7中认为需要List\u003cObject\u003e processStringList(Collections.emptyList()); //在Java7中可以编译通过 processStringList(Collections.\u003cString\u003eemptyList()); 通配符 泛型代码中,”?“叫作通配符，代表着一种未知类型。通配符可以在众多场景中使用：作为从参数类型、字段或者本地变量；有时甚至可以是返回类型。通配符不能用在泛型方法调用的类型参数、泛型类实例创建或超类。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:6:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"上界通配符 你可以使用上界通配符放大变量的限制。例如你想写一个能在List\u003cInteger\u003e中运行的方法,就可以使用上界通配符实现。 使用如\u003c? extends A\u003e声明。在这种情况下，extends是广义的意味着\"extends(类)“或\"implements(接口)\"。 例如： public static void process(List\u003c? extends Foo\u003e list) { /* ... */ } public static void process(List\u003c? extends Foo\u003e list) { for (Foo elem : list) { // elem可以使用任何定义在Foo类中的方法。 } } public static double sumOfList(List\u003c? extends Number\u003e list) { double s = 0.0; for (Number n : list) s += n.doubleValue(); return s; } List\u003cDouble\u003e ld = Arrays.asList(1.2, 2.3, 3.5); System.out.println(\"sum = \" + sumOfList(ld));//sum=7.0 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:7:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"无界通配符 无界通配符如:List\u003c?\u003e意为未知类型的列表。有两种场景适用无界通配符: 如果你在编写一个能用Object类提供的方法实现的方法 当代码使用了泛型类中不依赖于类型参数的方法，例如List.size或List.clear。Class\u003c?\u003e就经常被使用,因为Class\u003cT\u003e中的多数方法不依赖T。 考虑下面的printList方法: public static void printList(List\u003cObject\u003e list) { for (Object elem : list) System.out.println(elem + \" \"); System.out.println(); } printList并不能打印任何类型的列表,它仅打印Object实例。因为像例如List\u003cInteger\u003e不是List\u003cObject\u003e的子类型。使用无界通配符可实现打印任意类型列表： public static void printList(List\u003c?\u003e list) { for (Object elem: list) System.out.print(elem + \" \"); System.out.println(); } List\u003cInteger\u003e li = Arrays.asList(1, 2, 3); List\u003cString\u003e ls = Arrays.asList(\"one\", \"two\", \"three\"); printList(li); printList(ls); List\u003cObject\u003e与List\u003c?\u003e是不同的,你可以往List\u003cObject\u003e插入Object或任意Object的子类型,但你仅能插入null到List\u003c?\u003e。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:8:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"下界通配符 下界通配符将未知类型限定为特定类型或该类型的超类,使用\u003c? super A\u003e声明。下界通配符与上界通配符不能同时使用。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:9:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"通配符和子类型 可以使用通配符创建泛型中的类型关系,尽管List\u003cInteger\u003e和List\u003cNumber\u003e没有关系,但是它们的父类型都是List\u003c?\u003e。 List\u003c? extends Integer\u003e intList = new ArrayList\u003c\u003e(); List\u003c? extends Number\u003e numList = intList; // OK. List\u003c? extends Integer\u003e is a subtype of List\u003c? extends Number\u003e 下图显示了几个List类之间的关系: ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:10:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"通配符捕获和辅助方法 有时编译器会推断通配符的类型,这种场景叫通配符捕获。 下面的WildcardError类在编译时会产生一个捕获错误: import java.util.List; public class WildcardError { void foo(List\u003c?\u003e i) { i.set(0, i.get(0)); } } //Java7 WildcardError.java:6: error: method set in interface List\u003cE\u003e cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 1 error 你可以通过编写一个私有的辅助方法来捕获通配符。 public class WildcardFixed { void foo(List\u003c?\u003e i) { fooHelper(i); } // Helper method created so that the wildcard can be captured // through type inference. //通过该方法,编译器推断T就是被捕获的CAP#1变量的类型 private \u003cT\u003e void fooHelper(List\u003cT\u003e l) { l.set(0, l.get(0)); } } 约定辅助方法命名为originalMethodNameHelper（原方法名+Helper）。 再看一个更复杂的例子： import java.util.List; public class WildcardErrorBad { void swapFirst(List\u003c? extends Number\u003e l1, List\u003c? extends Number\u003e l2) { Number temp = l1.get(0); l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, // got a CAP#2 extends Number; // same bound, but different types l2.set(0, temp); // expected a CAP#1 extends Number, // got a Number } } List\u003cInteger\u003e li = Arrays.asList(1, 2, 3); List\u003cDouble\u003e ld = Arrays.asList(10.10, 20.20, 30.30); //这种情况没有辅助方法可以解决,因为把Double值添加到Integer列表中就是语法错误的 swapFirst(li, ld); // WildcardErrorBad.java:7: error: method set in interface List\u003cE\u003e cannot be applied to given types; l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number WildcardErrorBad.java:10: error: method set in interface List\u003cE\u003e cannot be applied to given types; l2.set(0, temp); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number WildcardErrorBad.java:15: error: method set in interface List\u003cE\u003e cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 3 errors ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:11:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"使用指南 输入变量 输入变量将数据提供给代码。例如copy(src,dest)方法src是输入参数 输出变量 输出变量接收在其他地方使用的数据。如copy(src,dest)方法dest是输出参数 当然有些变量既是输入也是输出,可以参考以下几点使用通配符: 输入变量使用上界通配符定义(使用extends关键字) 输出变量使用下界通配符定义(使用super关键字) 可以使用Object类中方法访问输入变量时,使用无界通配符 代码需要访问既是输入又是输出的变量时,不要使用通配符 这些指南不适用于方法返回类型。应避免使用通配符作为返回类型。 像List\u003c? extends … \u003e这样的列表可以认为它仅是只读的(并非严格意义上)。 class NaturalNumber { private int i; public NaturalNumber(int i) { this.i = i; } // ... } class EvenNumber extends NaturalNumber { public EvenNumber(int i) { super(i); } // ... } List\u003cEvenNumber\u003e le = new ArrayList\u003c\u003e(); List\u003c? extends NaturalNumber\u003e ln = le; ln.add(new NaturalNumber(35)); // compile-time error 因为List\u003cEvenNumber\u003e是List\u003c? extends NaturalNumber\u003e的子类型,所以可以把le赋值给ln。但是你不能使用ln添加自然数,因为它实际上是偶数列表,下列操作是可以的(从以下几点可以看出List\u003c? extends NaturalNumber\u003e并不是严格语意上的只读): 添加null 调用clear 获取迭代器并调用remove 捕获通配符并写入列表中读取的元素 类型擦除 Java语言引入泛型以在编译期提供严格类型检查。Java编译器应用类型擦除来实现泛型： 如果类型参数是无界的，使用它们的边界或Object代替所有的类型参数 如有必要执行类型转换 生成桥接方法以保证在泛型类型继承中的多态性 类型擦除确保没有为参数化类型创建新类,因此,泛型没有运行时开销。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:12:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型类中的擦除 Java编译器擦除所有类型参数,如果类型参数是有界的,则使用首个边界代替;如果类型参数是无界的,则使用Object代替。 考虑下面的泛型类： public class Node\u003cT\u003e { private T data; private Node\u003cT\u003e next; public Node(T data, Node\u003cT\u003e next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } 因为类型参数是无界的,Java编译器使用Object代替: public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } 当泛型类Node使用有界类型参数时,Java编译器使用首个边界类代替类型参数: public class Node\u003cT extends Comparable\u003cT\u003e\u003e { private T data; private Node\u003cT\u003e next; public Node(T data, Node\u003cT\u003e next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } //泛型擦除后 public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:13:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的擦除 与泛型类中的擦除类似: // Counts the number of occurrences of elem in anArray. // public static \u003cT\u003e int count(T[] anArray, T elem) { int cnt = 0; for (T e : anArray) if (e.equals(elem)) ++cnt; return cnt; } //擦除后 public static int count(Object[] anArray, Object elem) { int cnt = 0; for (Object e : anArray) if (e.equals(elem)) ++cnt; return cnt; } class Shape { /* ... */ } class Circle extends Shape { /* ... */ } class Rectangle extends Shape { /* ... */ } public static \u003cT extends Shape\u003e void draw(T shape) { /* ... */ } //擦除后 public static void draw(Shape shape) { /* ... */ } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:14:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"类型擦除的影响和桥接方法 以下例子展示了编译器在类型擦除的过程中如何创建桥接方法。 public class Node\u003cT\u003e { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node\u003cInteger\u003e { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = mn.data; //类型擦出后 MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning // Note: This statement could instead be the following: // Node n = (Node)mn; // However, the compiler doesn't generate a cast because // it isn't required. n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = (Integer)mn.data; 桥接方法 当编译一个继承于参数化类的类或接口,或实现一个参数化接口时,编译器会自动创建一个桥接方法。 类型擦除后，Node和MyNode类： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 可以注意到类型擦除后,方法签名不匹配了,Node.setData(T)方法变成了Node.setData(Object)。也就是说MyNode.setData(Integer)没有重写Node.setData(Object)。 为了保证泛型擦出后的多态性，编译器生成了一个桥接方法： class MyNode extends Node { // Bridge method generated by the compiler // public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } 桥接方法MyNode.setData(object)委托给了原始方法MyNode.setData(Integer)。所以n.setData(“Hello”);语句调用的是 MyNode.setData(Object)方法，所以才会抛出ClassCastException（因为\"Hello\"不能转换成Integer）。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:15:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"非具体类型（Non-Reifiable Types） 具体类型指在类型信息在运行时可知道类型,包括: 原始类型 非泛型类型 raw type 无界通配符调用 非具体类型指类型信息在编译器被擦除的类型:调用不是由无界通配符定义的泛型类型。其类型信息在运行时不完全可知,如List\u003cString\u003e和List\u003cNumber\u003e，JVM在运行时无法分辨这两者点区别。 在某些场景下非具体类型是不能使用的，如instanceof语句或作为数组元素。 堆污染 当一个参数化类型的变量指向一个不是这些参数化类型的对象时，就会发生堆污染。如果该程序执行某些操作会引起编译时的未受检警告，则会发生这种情况。当包含一个参数化类型的操作(如转换或方法调用)在编译时或运行时无法被验证时,就会生成未受检警告。例如，混用原始类型（raw type）和参数化类型时,或执行未受检转换时就会出现堆污染。 含非具体类型形参的可变参方法的漏洞 包含可变长入参的泛型方法可能造成堆污染： public class ArrayBuilder { public static \u003cT\u003e void addToList (List\u003cT\u003e listArg, T... elements) { for (T x : elements) { listArg.add(x); } } public static void faultyMethod(List\u003cString\u003e... l) { Object[] objectArray = l; // Valid但是可能产生堆污染 objectArray[0] = Arrays.asList(42); String s = l[0].get(0); // ClassCastException thrown here } } public class HeapPollutionExample { public static void main(String[] args) { List\u003cString\u003e stringListA = new ArrayList\u003cString\u003e(); List\u003cString\u003e stringListB = new ArrayList\u003cString\u003e(); ArrayBuilder.addToList(stringListA, \"Seven\", \"Eight\", \"Nine\"); ArrayBuilder.addToList(stringListB, \"Ten\", \"Eleven\", \"Twelve\"); List\u003cList\u003cString\u003e\u003e listOfStringLists = new ArrayList\u003cList\u003cString\u003e\u003e(); ArrayBuilder.addToList(listOfStringLists, stringListA, stringListB); ArrayBuilder.faultyMethod(Arrays.asList(\"Hello!\"), Arrays.asList(\"World!\")); } } //warning: [varargs] Possible heap pollution from parameterized vararg type T 当编译器进入一个可变长参数方法时，会将其转换成数组。但是Java语言不允许创建参数化类型的数组。Java编译器会将T…elements转换成Object[] elements，这可能产生堆污染。 阻止带不可变类型的可变长参数方法的警告 @SafeVarargs @SuppressWarnings({“unchecked”,“varargs”}):注意这无法抑制从方法调用处产生的警告 泛型约束 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:16:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能使用原始类型实例化泛型类型 class Pair\u003cK, V\u003e { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } // ... } Pair\u003cint, char\u003e p = new Pair\u003c\u003e(8, 'a'); // compile-time error ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:17:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建类型参数的实例 public static \u003cE\u003e void append(List\u003cE\u003e list) { E elem = new E(); // compile-time error list.add(elem); } 但是你可以通过反射创建类型参数的对象 public static \u003cE\u003e void append(List\u003cE\u003e list, Class\u003cE\u003e cls) throws Exception { E elem = cls.newInstance(); // OK list.add(elem); } //调用 List\u003cString\u003e ls = new ArrayList\u003c\u003e(); append(ls, String.class); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:18:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能声明为静态属性 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:19:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能转换或使用instanceof语句 public static \u003cE\u003e void rtti(List\u003cE\u003e list) { if (list instanceof ArrayList\u003cInteger\u003e) { // compile-time error // ... } } List\u003cInteger\u003e li = new ArrayList\u003c\u003e(); List\u003cNumber\u003e ln = (List\u003cNumber\u003e) li; // compile-time error 有时候转换是允许的： List\u003cString\u003e l1 = ...; ArrayList\u003cString\u003e l2 = (ArrayList\u003cString\u003e)l1; // OK 另外，无界通配符可以使用instanceof： public static void rtti(List\u003c?\u003e list) { if (list instanceof ArrayList\u003c?\u003e) { // OK; instanceof requires a reifiable type // ... } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:20:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建参数化类型的数组 List\u003cInteger\u003e[] arrayOfLists = new List\u003cInteger\u003e[2]; // compile-time error //如果不同的类型插入到同一个数组将会产生异常 Object[] strings = new String[2]; strings[0] = \"hi\"; // OK strings[1] = 100; // An ArrayStoreException is thrown. //所以类似的，不允许这样创建参数化类型的数组 Object[] stringLists = new List\u003cString\u003e[2]; // compiler error, but pretend it's allowed stringLists[0] = new ArrayList\u003cString\u003e(); // OK stringLists[1] = new ArrayList\u003cInteger\u003e(); // An ArrayStoreException should be thrown, // but the runtime can't detect it. ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:21:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建，捕获或抛出参数化类型的对象 泛型类不能直接或间接地继承Throwable类。 // Extends Throwable indirectly class MathException\u003cT\u003e extends Exception { /* ... */ } // compile-time error // Extends Throwable directly class QueueFullException\u003cT\u003e extends Throwable { /* ... */ // compile-time error public static \u003cT extends Exception, J\u003e void execute(List\u003cJ\u003e jobs) { try { for (J job : jobs) // ... } catch (T e) { // compile-time error // ... } } 但是可以在throws语句中使用类型参数： class Parser\u003cT extends Exception\u003e { public void parse(File file) throws T { // OK // ... } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:22:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"参数在类型擦除后一眼的方法不能重载 public class Example { //'print(Set\u003cString\u003e)' clashes with 'print(Set\u003cInteger\u003e)'; both methods have same erasure public void print(Set\u003cString\u003e strSet) { } public void print(Set\u003cInteger\u003e intSet) { } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:23:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["数据结构"],"content":"多路查找树(m-way search tree) 多路查找树是一种用来高效搜索或检索数据的数据结构。m表示最大子节点数。如二叉树也叫2-way查找树。多路查找树主要用来优化搜索(因为树高度更小、每个节点存储的key更多)，最优时间复杂度为O($\\log_mn$)。 最大子节点数为m 节点最大元素数为m-1 最大元素数$m^(h+1)-1$,h为树的高度,这里高度定义为树中任一节点到根节点的路径最大值 最优时间复杂度为O($\\log_mn$),这可以通过使用不同的平衡策略可以达到,如B树：除根节点外的其他非叶子节点最少有m/2个子节点;最差时间复杂度0(n) 元素升序排列:左子树值小于根节点,右子树值大于根节点。具体来说：前i个子节点的值均小于第i个key的值;后m-i个子节点的值均大于第i个key的值 以下面的5路查找树为例: public class MultiwaySearchTree { public static class TreeNode { public int val; //左子节点 public TreeNode left; //右子节点 public TreeNode right; //下一个节点 public TreeNode next; public TreeNode(int val, TreeNode right, TreeNode left, TreeNode next) { this.val = val; this.right = right; this.left = left; this.next = next; } public TreeNode(int val) { this.val = val; } @Override public String toString() { return \"TreeNode{\" + \"val=\" + val + \", left=\" + left + \", right=\" + right + \", next=\" + next + '}'; } } public static TreeNode search(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; //如果查找值小于当前节点值,以当前节点的左子节点为根继续查找 if (root.val \u003e val) { if (root.left == null) return null; return search(root.left, val); } //如果查找值大于当前节点值且当前节点没有后续节点,以当前节点的右子节点为根继续查找 if (root.next == null) { if (root.right == null) return null; return search(root.right, val); } if (root.next.val == val) return root.next; //如果查找值介于当前节点值和当前节点的下一节点值之间,则以当前节点的右子节点为根继续查找 if (root.next.val \u003c val) return search(root.next, val); //如果查找值大于当前节点和当前节点的下一节点值,则以当前节点的下一节点为根继续查找 return search(root.right, val); } public static void main(String[] args) { TreeNode root = new TreeNode(18); root.next = new TreeNode(54); root.next.next = new TreeNode(86); root.next.next.next = new TreeNode(400); root.next.next.next.right = new TreeNode(450); root.next.next.next.right.next = new TreeNode(470); root.left = new TreeNode(5); root.left.next = new TreeNode(10); root.left.right = new TreeNode(7); root.left.right.next = new TreeNode(9); root.right = new TreeNode(25); root.right.next = new TreeNode(35); root.right.next.next = new TreeNode(40); root.right.next.next.right = new TreeNode(45); root.right.left = new TreeNode(19); root.right.left.next = new TreeNode(20); root.right.left.next.next = new TreeNode(21); root.right.left.next.next.next = new TreeNode(22); System.out.println(search(root, 40)); } } 可能以上代码例子还不太直观，不能体现一个节点可以有多个key，下面再看一个例子。 相应的数据结构可以表示为 public class Node { int count;//子节点数 int[] value = new int[3]; Node[] child = new Node[4]; } B树（B-tree） B树是一种特殊的多路查找树(B树也是平衡版的二叉树)：B树是自平衡的多路查找树数据结构，能以对数时间搜索，访问，插入和删除元素。B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快访问速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。 B树相较于多路查找树有以下两个特性： 自平衡：每个叶子节点深度相同 除了根节点的节点的元素在[ceil(m/2),m-1]之间(也有说是[m/2-1,m-1])，根节点的元素个数在[1,m-1]之间 如果根节点不是叶子节点，那么它至少有两个子节点（2-3树是最简单的B树）；内部节点最少有ceil(m/2)个子节点 插入、删除和搜索操作时间复杂度为O($logn$)，n为树中存储key的个数。另外其空间复杂度为O(n)。 辅助存储设备通常容量大但读写慢，因此需要像B树这样的数据结构来减少磁盘访问。其他的数据结构像二叉查找树，avl树，红黑树等的每个节点仅存储一个值，如果需要存储大量值，树都高度将会变大导致访问时间增加。 B树能在一个节点存储多个值并且有多个子节点，这减少了树都高度，从而让磁盘访问更快。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:0:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 插入过程如下: 1.如果树为空,构建一个根节点并插入值 2.寻找合适的节点插入(符合B树特性的节点) 3.如果节点没有多余的位置，按以下步骤执行： 3.1按升序排列插入元素 3.2当前节点已超过最大key数量限制,按中间值分裂 3.3向上弹出中间值,中间值左边的值作为左子节点,中间值右边的值作为右子节点 3.4如果上层节点的值未满,则按升序插入到上层节点 3.5如果上层节点的值已满,重复步骤3 例:构建一个B树，M=3，值为12,23,6,8,15,19,45,1,4,7,5。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:1:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在叶子节点 1.1叶子节点key数量大于最小key数量 1.1.1直接删除目标key 1.2叶子节点只有最小数量key 1.2.1从当前左兄弟节点借一个最大key(仅当左兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.2 1.2.2从当前右兄弟节点借一个最小key(仅当右兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.3 1.2.3与左兄弟节点和父节点key合并或者与右兄弟节点和父节点key合并,然后删除目标key 以M=5的一颗B树来演示上述步骤： ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在内部节点 2.1有序前驱(左子树最大元素) 2.1.1找到左子树中最大key代替要删除的目标key。左子树元素数量要大于节点最小元素数量 2.2有序后继(右子树最小元素) 2.2.1找到右子树中最小key代替要删除的目标key。右子树元素数量要大于节点最小元素数量 2.3上述都不满足,合并左右子节点和目标key,然后删除目标key ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 无法从左右子树取值时，合并导致高度减少。 以下Java代码来自java-algorithms-implementation仓库 package datastructure; import java.util.*; /** * @author cheysen * @date 2025/4/3 12:36 * @description B 树是一种树数据结构，它使数据保持排序并允许对数时间的搜索、顺序访问、插入和删除。 * B 树是二叉搜索树的泛化，因为一个节点可以有两个以上的子节点。与自平衡二叉搜索树不同，B 树针对读取和写入大型数据块的系统进行了优化。它通常用于数据库和文件系统。 **/ @SuppressWarnings(\"unchecked\") public class BTree\u003cT extends Comparable\u003cT\u003e\u003e implements Tree\u003cT\u003e { //2-3树是最简单的B树:最大key数量2,最大子节点数3,最小key数量2 private int minKeySize = 1; private int minChildrenSize = minKeySize + 1; private int maxKeySize = 2 * minKeySize; private int maxChildrenSize = maxKeySize + 1; private Node\u003cT\u003e root = null; private int size = 0; //默认2-3树 public BTree() { } //order:非根节点最少key数量 public BTree(int order) { this.minKeySize = order; this.minChildrenSize = minKeySize + 1; this.maxKeySize = 2 * minKeySize; this.maxChildrenSize = maxKeySize + 1; } public BTree\u003cT\u003e appendAdd(T value) throws Exception { boolean added = add(value); if (added) { return this; } else { throw new Exception(\"add \" + value + \" error\"); } } @Override public boolean add(T value) { if (root == null) { root = new Node\u003cT\u003e(null, maxKeySize, maxChildrenSize); root.addKey(value); } else { Node\u003cT\u003e node = root; while (node != null) { //没有子节点就在当前节点插入 if (node.numberOfChildren() == 0) { node.addKey(value); if (node.numberOfKeys() \u003c= maxKeySize) { break; } //key数量已满，需要分裂 split(node); break; } //否则，按有序的规则查找该插入的节点 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c= 0) { node = node.getChild(0); continue; } int numberOfKeys = node.numberOfKeys(); int last = numberOfKeys - 1; T greater = node.getKey(last); if (value.compareTo(greater) \u003e 0) { node = node.getChild(numberOfKeys); continue; } for (int i = 1; i \u003c node.numberOfKeys(); i++) { T prev = node.getKey(i - 1); T next = node.getKey(i); if (value.compareTo(prev) \u003e 0 \u0026\u0026 value.compareTo(next) \u003c= 0) { node = node.getChild(i); break; } } } } size++; return true; } @Override public T remove(T value) { T removed = null; Node\u003cT\u003e node = this.getNode(value); removed = remove(value, node); return removed; } @Override public boolean contains(T value) { Node\u003cT\u003e node = getNode(value); return node != null; } @Override public void clear() { root = null; size = 0; } @Override public int size() { return size; } @Override public boolean validate() { if (root == null) { return true; } return validateNode(root); } @Override public Collection\u003cT\u003e toCollection() { return new JavaCompatibleBTree\u003c\u003e(this); } @Override public String toString() { return TreePrinter.getString(this); } /** * 获取目标值所在节点 * @param value 要查找的值 * @return 目标值所在节点 */ private Node\u003cT\u003e getNode(T value) { Node\u003cT\u003e node = root; while (node != null) { //尝试是否比节点最小值小 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c 0) { if (node.numberOfChildren() \u003e 0) { node = node.getChild(0); } else { node = null; } continue; } //尝试是否比节点最大值大 int numberOfKeys = node.numberOfKeys(); int lastIndex = numberOfKeys - 1; T greater = node.getKey(lastIndex); if (value.compareTo(greater) \u003e 0) { if (node.numberOfChildren() \u003e numberOfKeys) { node = node.getChild(numberOfKeys); } else { node = null; } continue; } //不满足极大极小情况,在中间值中比较 for (int i = 0; i \u003c numberOfKeys; i++) { T currentValue = node.getKey(i); if (currentValue.compareTo(value) == 0) { return node; } int next = i + 1; if (next \u003c= lastIndex) { T nextValue = node.getKey(next); //目标值介于第i与第i+1个key之间时,在第i+1个子节点(如果有)中继续查找 if (value.compareTo(currentValue) \u003e 0 \u0026\u0026 value.compareTo(nextValue) \u003c 0) { if (next \u003c node.numberOfChildren()) { node = node.getChild(next); break; } return null; } } } } return null; } /** * 从节点中删除值 * @param value 要删除的值 * @param node 要删除的值所在节点 * @return true-删除成功 */ private T remove(T value, Node\u003cT\u003e node) { if (node == null) { return null; } T removed = null; int index = node.indexOf(value); removed = node.removeKey(index); //叶子节点元素的删除:1.直接删除 2.兄弟节点借值 3.合并兄弟节点(之一)与父节点key if (node.numberOfChildren() == 0) { if (node.parent != null \u0026\u0026 node.numberOfKeys() \u003c minKeySize) { this.combined(node); } else if (node.parent == n","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 B+树都插入根B树类似,需要注意以下两点 内部节点分裂时,key不重复 子节点分裂时,分裂的中间值在右子节点重复 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:3:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key仅在叶子节点 节点key数量大于最小key数量 直接删除 节点只有最小key数量 删除该key，从直接兄弟节点借一个key，将兄弟节点的中间key移到父节点 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key存在于内部节点和叶子节点 key数量大于最小key数量 直接删除内部节点和叶子节点的key，用有序后继填充内部节点删除的位置 只有最小key数量且key所在位置相邻 删除该key,从直接兄弟节点借一个值，填充内部节点删除的位置 只有最小key数量且key所在位置不相邻 删除该key,合并兄弟节点，用有序后续填充内部节点删除的位置 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["Java编程"],"content":"1. 枚举类型的介绍 枚举类型是一种特殊的数据类型，它使得变量成为一组预定义常量。所以在需要表示一组固定常量时应尽量使用枚举类型。通过关键字enum来定义枚举类，它和普通类一样可以有构造器、成员变量、方法。 1.1 枚举类的特性 所有的枚举类都隐式的继承java.lang.Enum，Java不允许多继承，所以枚举类不能再继承其他任何类，但可以实现接口 枚举类被隐式地声明为final，所以也不能被其他任何类继承 枚举类型的构造函数修饰符必须是private。定义枚举常量时会自动调用，不能自己调用枚举的构造函数 枚举类的实例必须在第一行列出，并且枚举值默认被public static final修饰 编译时编译器会自动帮我们添加两个静态方法values()和valueOf() 1.2 枚举类的原理 下面我们定义了一个枚举类并让它实现Info接口，这样可以让枚举值提供不同的实现，当然也可以在枚举类里面定义一个抽象方法，这样枚举值也必须实现此抽象方法才可，效果都一样。 public enum Season implements Info{ SPRING(\"spring\",\"春暖花开\"){ public void show(){ System.out.println(\"春天在哪里\"); } }, SUMMER(\"summer\",\"夏日炎炎\"){ public void show(){ System.out.println(\"生如夏花\"); } }, AUTUMN(\"autumn\",\"秋高气爽\"){ public void show(){ System.out.println(\"秋\"); } }, WINTER(\"winter\",\"白雪茫茫\"){ public void show(){ System.out.println(\"冷\"); } }; private final String seasonName; private final String seasonDesc; Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } } 可以看到该枚举类编译后的class文件，其中还包括了四个枚举值对应的class文件，而且其后还带有序号。在枚举实例创建时会给每个枚举值指定一个整形常量值（序号），若没有显示指定，则 整形常量值从0开始递增。这其实是与父类Enum有关，后面会介绍。 下面是利用javap工具查看Season.java经过编译后的字节码（请忽略乱码–.–）: \"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javap.exe\" -c pre.chl.enums.Season Compiled from \"Season.java\" public abstract class pre.chl.enums.Season extends java.lang.Enum\u003cpre.chl.enums.Season\u003e implements pre.chl.enums.Info { public static final pre.chl.enums.Season SPRING; public static final pre.chl.enums.Season SUMMER; public static final pre.chl.enums.Season AUTUMN; public static final pre.chl.enums.Season WINTER; public static pre.chl.enums.Season[] values(); Code: 0: getstatic #2 // Field $VALUES:[Lpre/chl/enums/Season; 3: invokevirtual #3 // Method \"[Lpre/chl/enums/Season;\".clone:()Ljava/lang/Object; 6: checkcast #4 // class \"[Lpre/chl/enums/Season;\" 9: areturn public static pre.chl.enums.Season valueOf(java.lang.String); Code: 0: ldc #5 // class pre/chl/enums/Season 2: aload_0 3: invokestatic #6 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #5 // class pre/chl/enums/Season 9: areturn public java.lang.String getSeasonName(); Code: 0: aload_0 1: getfield #8 // Field seasonName:Ljava/lang/String; 4: areturn public java.lang.String getSeasonDesc(); Code: 0: aload_0 1: getfield #9 // Field seasonDesc:Ljava/lang/String; 4: areturn public java.lang.String toString(); Code: 0: new #10 // class java/lang/StringBuilder 3: dup 4: invokespecial #11 // Method java/lang/StringBuilder.\"\u003cinit\u003e\":()V 7: ldc #12 // String Season{seasonName=' 9: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 12: aload_0 13: getfield #8 // Field seasonName:Ljava/lang/String; 16: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: bipush 39 21: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 24: ldc #15 // String , seasonDesc=' 26: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: aload_0 30: getfield #9 // Field seasonDesc:Ljava/lang/String; 33: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 36: bipush 39 38: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 41: bipush 125 43: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 46: invokevirtual #16 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 49: areturn pre.chl.enums.Season(java.lang.String, int, java.lang.String, java.lang.String, pre.chl.enums.Season$1); Code: 0: aload_0 1: aload_1 2: iload_2 3: aload_3 4: aload 4 6: invokespecial #1 // Method \"\u003cinit\u003e","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:1","tags":["Java基础"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Java编程"],"content":"2. 枚举类的使用 2.1 定义 public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } 枚举值之间使用\",“分隔，如果后面没有属性或方法，最后加不加”;“都行。但如果有就一定要加”;\" public enum PurOrderSplitEnum { NORELEASEERPBILLCOUNT(\"1\", \"待发布\"), RELEASEERPBILLCOUNT(\"2\", \"待买方确认\"), PURCONFIRMINGCOUNT(\"3\", \"买方变更中\"); private String code; private String name; public static Map\u003cString, String\u003e code2name = new HashMap(); public static Map\u003cString, String\u003e code2Muname = new HashMap(); private PurOrderSplitEnum(String code, String name) { this.code = code; this.name = name; } public String getCode() { return this.code; } public String getName() { return this.name; } static { code2name.put(NORELEASEERPBILLCOUNT.getCode(), NORELEASEERPBILLCOUNT.getName()); code2name.put(RELEASEERPBILLCOUNT.getCode(), RELEASEERPBILLCOUNT.getName()); code2name.put(PURCONFIRMINGCOUNT.getCode(), PURCONFIRMINGCOUNT.getName()); code2Muname.put(NORELEASEERPBILLCOUNT.getCode(), \"NORELEASEERPBILLCOUNT\"); code2Muname.put(RELEASEERPBILLCOUNT.getCode(), \"RELEASEERPBILLCOUNT\"); code2Muname.put(PURCONFIRMINGCOUNT.getCode(), \"PURCONFIRMINGCOUNT\"); } } 2.2 结合Switch 在switch中使用枚举，可以让我们的代码可读性更好 public class EnumTest { Day day; public EnumTest(Day day) { this.day = day; } public void tellItLikeItIs() { switch (day) { case MONDAY: System.out.println(\"周一还行吧\"); break; case FRIDAY: System.out.println(\"周五很nice\"); break; case SATURDAY: case SUNDAY: System.out.println(\"周末超级棒\"); break; default: System.out.println(\"额....\"); break; } } public static void main(String[] args) { EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); EnumTest fifthDay = new EnumTest(Day.FRIDAY); fifthDay.tellItLikeItIs(); EnumTest sixthDay = new EnumTest(Day.SATURDAY); sixthDay.tellItLikeItIs(); EnumTest seventhDay = new EnumTest(Day.SUNDAY); seventhDay.tellItLikeItIs(); } //输出结果 /* 周一还行吧 额.... 周五很nice 周末超级棒 周末超级棒 */ 2.3 valueOf方法 把字符串转成对应类型的枚举值，如： String str = \"SPRING\"; Season season2 = Season.valueOf(str); //Season season2 = Season.valueOf(Season.class,str);跟上面是等价的 System.out.println(season2 == season1);//true 2.4 values()和其他方法 values()方法可以返回所有定义的枚举值，name()方法返回的是枚举的名称，不是枚举值里面的属性名称，这里需要注意一下。 Season season1 = Season.SPRING; for(Season season:Season.values()){ System.out.println(season); } season1.show(); System.out.println(season1.name()); System.out.println(\"SPIRNG的序号:\" + season1.ordinal()); //输出结果 /* Season{seasonName='spring', seasonDesc='春暖花开'} Season{seasonName='summer', seasonDesc='夏日炎炎'} Season{seasonName='autumn', seasonDesc='秋高气爽'} Season{seasonName='winter', seasonDesc='白雪茫茫'} 春天在哪里 SPRING 0 */ 2.5 使用接口组织枚举 在接口中定义枚举类，可以将数据分组。 public interface Animal { enum Dog implements Animal { HUSKY,GOLDEN_RETRIEVER,ALASKAN_MALAMUTE } enum Cat implements Animal { PERSIAN,RAGDOLL,BIRMAN } } // Animal dog = Animal.Dog.ALASKAN_MALAMUTE; // Animal cat = Animal.Cat.BIRMAN; 2.6 EnumSet和EnumMap Set类型是枚举集或Map的key是枚举值时，使用这两者将会更加高效。这里只摘取Java API文档的部分说明，详细的方法大家可以自己查找文档。 EnumMap 用于枚举类型键的专用Map实现。 枚举映射中的所有键必须来自创建映射时显式或隐式指定的单个枚举类型。 枚举映射在内部表示为数组。 这种表现非常紧凑和高效。 枚举映射按其键的自然顺序（枚举常量的声明顺序）维护。 这反映在集合视图（keySet（），entrySet（）和values（））返回的迭代器中。 集合视图返回的迭代器非常一致：它们永远不会抛出ConcurrentModificationException，它们可能会也可能不会显示迭代进行过程中对映射所做的任何修改的影响。 Key不允许为null。 尝试插入null将抛出NullPointerException。 但是，尝试测试是否存在空键或删除空键将正常运行。 value允许为null。 与大多数集合实现一样，EnumMap不同步。 如果多个线程同时访问枚举映射，并且至少有一个线程修改了映射，则应该在外部进行同步。 这通常通过在自然封装枚举映射的某个对象上同步来完成。 如果不存在此类对象，则应使用Collections.synchronizedMap（java.util.Map \u003cK，V\u003e）方法“包装”映射。 这最好在创建时完成，以防止意外的不同步访问： Map \u003cEnumKey，V\u003e m= Collections.synchronizedMap（new EnumMap \u003cEnumKey，V\u003e（...））; 说明：所有基本操作都在恒定时间内执行。 它们很可能（虽然不能保证）比它们对应的HashMap更快。 EnumSet 用于枚举类型的专用Set实现。 枚举集中的所有元素必须来自单个枚举类型，该类型在创建集时显式或隐式指定。 枚举集在内部表示为位向量。 这种表现非常紧凑和高效。 这个类的空间和时间性能应该足够好，以允许它作为传统的基于int的“位标志”的高性能、类型安全的替代品。 如果它们的参数也是枚举集，即使批量操作（例如containsAll和retainAll）也应该非常快速地运行。 迭代器方法返回的迭代器以其自然顺序（枚举常量声明的顺序）遍历元素。 返回的迭代器是弱一致的：它永远不会抛出ConcurrentModificationException，它可能会也可能不会显示迭代进行过程中对集合所做的任何修改的影响。 不允许使用空元素。 尝试插入null元素将抛出NullPointerException","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:2","tags":["Java基础"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["网络安全"],"content":"1. XSS简介 跨站脚本(Cross Site Script)为了避免与CSS混淆,简称XSS。XSS是指攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，在输入框添加一些代码，嵌入到web页面中，使别的用户访问会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。XSS又分为反射型、存储型和DOM-Based型。 XSS的危害包括： 盗取用户Cookie DDOS客户端浏览器 盗窃企业重要的具有商业价值的资料 爆发web2.0蠕虫 强制发送电子邮件 网站挂马，钓鱼攻击 劫持用户web行为甚至渗透内网 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:1:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"2. 原理 （1）反射型 服务端返回脚本，客户端执行。如URL注入非法脚本，然后诱导用户点击该链接，但是一般浏览器都会有基本防御措施，自带拦截过滤；服务端返回的富文本中包含非法脚本，被直接展示。 （2）存储型 后台被动存储了非法脚本，并且前端直接展示。如发帖或留言中发出包含恶意代码的内容,其他用户访问该内容后,满足特定条件即触发,这种需要后台不过滤信息,并且前端展示时也不过滤信息。 （3）DOM-Based型 基于DOM或本地的XSS攻击。如wifi流量劫持、DNS劫持并直接返回钓鱼页面。本质是需要更改DOM，再排除自己攻击自己。某些反射型的攻击也能造成这个后果-通过url控制DOM。在传统的XSS中，恶意JavaScript脚本在页面加载时执行，而在基于DOM的XSS中，恶意JavaScript脚本在页面加载后的某个时刻执行。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:2:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"3.自动化XSS Browser Exploitation Framework(BeEF),是目前强大的浏览器开源渗透测试框架,通过XSS漏洞配合JS脚本和Metasploit进行渗透。它是基于Ruby编写，支持图形化界面，操作简单。 Kali linux已经自带BeEF,另外我使用一个开源的靶机OWASP Broken Web Apps来练习。 在靶机的低安全级别下执行一个存储型的XSS： 然后使用win10的Google浏览器访问靶机的相应被注入脚本的页面后，BeEF中的记录： 之后就可以使用beef控制用户的浏览器进行多种操作（比如钓鱼），但是这里并没有win10的记录，原因是chrome对该XSS进行了过滤。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:3:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"4. 如何预防 （1）编码，转义用户输入，编码可在前端和后端中进行。常见的如下图的HTML转义 但是编码并不适用所有情况，比如当用户需要提供一个URL或者编写用户配置文件时，对输入编码是不友好的，不应对用户的自定义配置做限制，所以需要使用验证。 （2）验证，过滤用户输入。有两种实现方式 分类策略，使用白名单或黑名单分类 验证结果，拒绝或删除不合法的输入 （3）CSP内容安全策略（CSP） CSP用于约束浏览器只能使用从可信来源下载的资源。资源是页面引用的脚本，样式表，图像或其他类型的文件。这样即使攻击者成功将恶意内容注入到网站，CSP也可以防止它被执行。 CSP可用于执行以下规则： 没有不受信任的来源。外部资源只能从一组明确定义的可信来源加载。 没有内联资源。不会评估内联JavaScript和CSS。 无法使用JavaScript eval函数。 Content‑Security‑Policy: script‑src 'self' scripts.example.com; media‑src 'none'; img‑src *; default‑src 'self' http://*.example.com 以上CSP表明脚本只能从提供页面的主机和scripts.example.com下载。 无法从任何地方下载音频和视频文件。可以从任何主机下载图像文件。 所有其他资源只能从提供该页面的主机和example.com的任何子域下载。 (4) 其他方法 Cookie设置http-only。http-only标志可以防止cookie被“读取”，但不能防止被“写”,已证明有些浏览器的http-only标记可以被JavaScript写入覆盖，而这种覆盖可能被攻击者利用发动session fixation攻击。 WAF,大多数使用规则匹配,也能被绕过。 X-XSS-Protection也有助于在一些浏览器中防止某些XSS，但在某些情况下可以被绕过。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:4:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["Java编程"],"content":"JMM(Java Memory Model),Java内存模型,它是一种Java虚拟机需要遵守的规范，定义了线程间如何在内存中正确地交互。JDK5以后的JMM规范在JSR-133中详细列出。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1. 内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.1 为什么需要内存模型 多线程编程的困难在于很难对程序进行调式，如果控制不好，就会产生意料之外的结果。对于传统的单核CPU来说，由于是并发执行，即同一时刻只有一个线程在执行，所以一般不会出现数据的访问冲突。这也不是绝对的，单核多线程场景下，如果允许抢占式调度，仍存在线程安全问题。当前的处理器架构大多是多核+多级缓存+主存的模式，这样在多线程场景下就存在数据竞争从而造成缓存不一致的问题。另外CPU可能会对程序进行优化，进行指令重排序，只要重排后程序的语义没有发生变化，指令重排就是有可能发生的（编译器和JVM也存在指令重排），但这有时会让多线程执行的结果出乎意料。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:1","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.2 什么是内存模型 对处理器来说，内存模型定义了充分必要条件，以知道其他处理器对内存的写入对当前处理器可见，而当前处理器的写入对其他处理器可见。一些处理器使用强内存模型，即所有处理器在任何给定的内存位置上始终能看到完全相同的值,但这也不是绝对的,某些时候也需要使用特殊指令(称为内存屏障)来完成。其他处理器使用弱内存模型，需要内存屏障来刷新或使本地处理器缓存失效，以便查看其他处理器的写操作或使此处理器的写操作对其他处理器可见。这些内存屏障通常在lock和unlock时执行；对于使用高级语言的程序员来说，它们是不可见的。处理器的设计趋势是鼓励使用弱内存模型,因为它们的规范具有更强的可伸缩性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:2","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.3 其他语言有内存模型吗 大多数其他编程语言（如C和C ++）的设计并未直接支持多线程。 这些语言针对编译器和体系结构中发生的各种重排序提供的保护很大程度上取决于所使用的线程库（例如pthread），所使用的编译器以及运行代码的平台所提供的保证。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:3","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.Java内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.1 简介 Java内存模型是建立在内存模型之上的，它回答了当读取一个确定的字段时什么样的值是可见的。它将一个Java程序分解成若干动作（actions）并且为这些动作分配一个顺序。如果分配的这些顺序中能在对一个字段的写操作(write actions)和读操作(read actions)间形成一个叫happens-before的关系,那么Java内存模型保证了读操作将返回一个正确的值。 JMM规定所有实例域、静态域和数组元素存储在JVM内存模型的的堆中，堆内存在线程间是共享的。局部变量和异常处理器参数不会共享，他们不存在内存可见性问题。每个线程创建时JVM都会为其创建一个工作内存(栈空间),工作内存是每个线程的私有数据区域,线程对变量的操作必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作内存空间,然后对变量进行操作,操作完成后再将变量写回主内存`,不能直接操作主内存中的变量,各个线程中的工作内存中存储着主内存中的变量副本拷贝,因此线程间的通信必须通过主内存来完成。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:1","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.2 代码优化问题 上面一段代码,模拟了两个线程。期望可能是thread1执行一次count++,thread2修改flag的值,然后thread1退出循环。但是在未做同步控制的情况下多线程的执行情况是无法预料的。还存在一个很重要的问题，那就是编译器优化（这里编译器可以是Java编译器如JIT，JVM，CPU）。 对于thread1，没有对flag的写操作，所以编译器认为flag的值总是true，就将flag直接改为true来提高程序运行速度，这种优化是被允许的，因为对于它本身而言没有改变程序语义。 对于thread2，没有要求对flag的值要刷回主存，编译器就可能优化为忽略对flag的写指令，因为不刷回主存的值改变只有线程自己可见。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:2","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.3 指令重排序问题 对上图中三条指令，我们期望是顺序执行，但某些编译器为了提高速度，很可能对指令重排序变成下面一种执行顺序。 再来看看下面的例子 处理器A 处理器B a = 1; // 写操作A1 b =2; //写操作B1 x = b; //读操作A2 y = a; //读操作B2 初始状态 a = b = 0 结果 x = y = 0 之所以会出现以上结果,是因为处理器对写读指令进行了重排序,如将顺序A1 -\u003e A2重排成A2 -\u003e A1。对写读的重排序在x86架构下是被允许的。下图是不同架构下支持的重排序类型，这解释了为什么相同的程序在不同的架构系统下会产生不同的结果，因为编译器可能对你的代码进行了不同的重排序。 另外重排序需要考虑到数据之间的依赖性，比如下面3条指令,3是不会排到指令1之前的,因为指令3依赖于指令1的数据x。 int x = 1; //1 int y = 2; //2 y = x * x; //3 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:3","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.4 可见性问题 观察以上代码，写线程在自己的工作内存中改变了x的值却并未来得及刷回主内存,这样读线程读取到的值仍然是旧值,读线程此时对写线程的操作不可见。Java为此提供了volatile关键字解决方案：只要用volatile修饰变量x,对x进行原子操作后,x的值将立马刷回主内存,这样保证了读线程对写线程的可见性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:4","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.5 原子性问题 Java中long型占8字节,也就是64位,如果在64位操作系统中执行以上代码不存在原子性问题,对foo的写操作一步完成,但是在32位操作系统中这种写操作就失去了原子性。32位操作系统中对foo的写操作分两步进行-分别对高32位和低32位进行写操作。在这种情况下就可能产生如下结果 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:5","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.6 Happens-before规则 Happens-before表示动作上的偏序关系，官方文档对于该规则的定义如下 大致翻译一下就是: 两个动作可以由happends-before关系排序,如果一个动作happens-before另一个动作,那么第一个动作的执行结果对后一个动作可见。两个操作之间存在happens-before关系，并不意味着必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。例如，在线程构造的对象的每个字段中写入默认值不需要在该线程的开始之前发生，只要没有读取操作就会观察到该事实。另外，当两个动作存在于不同的线程中时，也存在这种关系，此种情况下两者之间会存在一个消息传递机制。 happens-before的8条规则如下： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:6","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.7 实现 字段域 方法域 final synchronized(method/block) volatile java.util.concurrent.* volatile public class VolatileFieldsVisivility{ int a = 0; volatile int x = 0; public void writeThread(){ a = 1; //1 x = 1; //2 } public void readThread(){ int r2 = x; //3 int d1 = a; //4 } } 假设写线程执行完后,问读线程读变量a的值是1还是0还是不确定?答案是确定的1，即使变量a未用volatile修饰。由上面给出的happens-before规则可推得：1 happens-before 2, 2 happens-before 3 , 3 happens-before 4 –\u003e 1 happens-before 4(传递性),即读线程读a的时候一定能看到写线程的执行结果，简短来说就是当一个线程对volatile修饰的变量写入，并且读取时也是此变量时在他之前的所有写操作被保证对其他线程是可见的。值得注意的是,写读操作必须是原子性的,如果被volatile修饰的是long或者double,那么这个64位的变量不能被拆分存储。也就是说volatile保证了可见性和有序性,但不保证原子性。 由于篇幅过长,其他方式的实现我将在其他文章中单独抽出来分析。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:7","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"3. 总结 Java内存模型就是Java语言在内存模型上的实现，它是为了保证多线程场景下的原子性、可见性和有序性提出的规范。Java语言提供了volatile、synchronized、final关键字和java.util.concurrent.*并发编程包来实现这些规范,这些提供给程序员的原语和包屏蔽了和底层交互的细节,让程序员可以更方便快捷地编程。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]