[{"categories":["数据结构"],"content":"多路查找树(m-way search tree) 多路查找树是一种用来高效搜索或检索数据的数据结构。m表示最大子节点数。如二叉树也叫2-way查找树。多路查找树主要用来优化搜索(因为树高度更小、每个节点存储的key更多)，最优时间复杂度为O($\\log_mn$)。 最大子节点数为m 节点最大元素数为m-1 最大元素数$m^(h+1)-1$,h为树的高度,这里高度定义为树中任一节点到根节点的路径最大值 最优时间复杂度为O($\\log_mn$),这可以通过使用不同的平衡策略可以达到,如B树：除根节点外的其他非叶子节点最少有m/2个子节点;最差时间复杂度0(n) 元素升序排列:左子树值小于根节点,右子树值大于根节点。具体来说：前i个子节点的值均小于第i个key的值;后m-i个子节点的值均大于第i个key的值 以下面的5路查找树为例: public class MultiwaySearchTree { public static class TreeNode { public int val; //左子节点 public TreeNode left; //右子节点 public TreeNode right; //下一个节点 public TreeNode next; public TreeNode(int val, TreeNode right, TreeNode left, TreeNode next) { this.val = val; this.right = right; this.left = left; this.next = next; } public TreeNode(int val) { this.val = val; } @Override public String toString() { return \"TreeNode{\" + \"val=\" + val + \", left=\" + left + \", right=\" + right + \", next=\" + next + '}'; } } public static TreeNode search(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; //如果查找值小于当前节点值,以当前节点的左子节点为根继续查找 if (root.val \u003e val) { if (root.left == null) return null; return search(root.left, val); } //如果查找值大于当前节点值且当前节点没有后续节点,以当前节点的右子节点为根继续查找 if (root.next == null) { if (root.right == null) return null; return search(root.right, val); } if (root.next.val == val) return root.next; //如果查找值介于当前节点值和当前节点的下一节点值之间,则以当前节点的右子节点为根继续查找 if (root.next.val \u003c val) return search(root.next, val); //如果查找值大于当前节点和当前节点的下一节点值,则以当前节点的下一节点为根继续查找 return search(root.right, val); } public static void main(String[] args) { TreeNode root = new TreeNode(18); root.next = new TreeNode(54); root.next.next = new TreeNode(86); root.next.next.next = new TreeNode(400); root.next.next.next.right = new TreeNode(450); root.next.next.next.right.next = new TreeNode(470); root.left = new TreeNode(5); root.left.next = new TreeNode(10); root.left.right = new TreeNode(7); root.left.right.next = new TreeNode(9); root.right = new TreeNode(25); root.right.next = new TreeNode(35); root.right.next.next = new TreeNode(40); root.right.next.next.right = new TreeNode(45); root.right.left = new TreeNode(19); root.right.left.next = new TreeNode(20); root.right.left.next.next = new TreeNode(21); root.right.left.next.next.next = new TreeNode(22); System.out.println(search(root, 40)); } } 可能以上代码例子还不太直观，不能体现一个节点可以有多个key，下面再看一个例子。 相应的数据结构可以表示为 public class Node { int count;//子节点数 int[] value = new int[3]; Node[] child = new Node[4]; } B树（B-tree） B树是一种特殊的多路查找树(B树也是平衡版的二叉树)：B树是自平衡的多路查找树数据结构，能以对数时间搜索，访问，插入和删除元素。B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快访问速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。 B树相较于多路查找树有以下两个特性： 自平衡：每个叶子节点深度相同 除了根节点的节点的元素在[ceil(m/2),m-1]之间(也有说是[m/2-1,m-1])，根节点的元素个数在[1,m-1]之间 如果根节点不是叶子节点，那么它至少有两个子节点（2-3树是最简单的B树）；内部节点最少有ceil(m/2)个子节点 插入、删除和搜索操作时间复杂度为O($logn$)，n为树中存储key的个数。另外其空间复杂度为O(n)。 辅助存储设备通常容量大但读写慢，因此需要像B树这样的数据结构来减少磁盘访问。其他的数据结构像二叉查找树，avl树，红黑树等的每个节点仅存储一个值，如果需要存储大量值，树都高度将会变大导致访问时间增加。 B树能在一个节点存储多个值并且有多个子节点，这减少了树都高度，从而让磁盘访问更快。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:0:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 插入过程如下: 1.如果树为空,构建一个根节点并插入值 2.寻找合适的节点插入(符合B树特性的节点) 3.如果节点没有多余的位置，按以下步骤执行： 3.1按升序排列插入元素 3.2当前节点已超过最大key数量限制,按中间值分裂 3.3向上弹出中间值,中间值左边的值作为左子节点,中间值右边的值作为右子节点 3.4如果上层节点的值未满,则按升序插入到上层节点 3.5如果上层节点的值已满,重复步骤3 例:构建一个B树，M=3，值为12,23,6,8,15,19,45,1,4,7,5。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:1:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在叶子节点 1.1叶子节点key数量大于最小key数量 1.1.1直接删除目标key 1.2叶子节点只有最小数量key 1.2.1从当前左兄弟节点借一个最大key(仅当左兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.2 1.2.2从当前右兄弟节点借一个最小key(仅当右兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.3 1.2.3与左兄弟节点和父节点key合并或者与右兄弟节点和父节点key合并,然后删除目标key 以M=5的一颗B树来演示上述步骤： ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在内部节点 2.1有序前驱(左子树最大元素) 2.1.1找到左子树中最大key代替要删除的目标key。左子树元素数量要大于节点最小元素数量 2.2有序后继(右子树最小元素) 2.2.1找到右子树中最小key代替要删除的目标key。右子树元素数量要大于节点最小元素数量 2.3上述都不满足,合并左右子节点和目标key,然后删除目标key ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 无法从左右子树取值时，合并导致高度减少。 以下Java代码来自java-algorithms-implementation仓库 package datastructure; import java.util.*; /** * @author cheysen * @date 2025/4/3 12:36 * @description B 树是一种树数据结构，它使数据保持排序并允许对数时间的搜索、顺序访问、插入和删除。 * B 树是二叉搜索树的泛化，因为一个节点可以有两个以上的子节点。与自平衡二叉搜索树不同，B 树针对读取和写入大型数据块的系统进行了优化。它通常用于数据库和文件系统。 **/ @SuppressWarnings(\"unchecked\") public class BTree\u003cT extends Comparable\u003cT\u003e\u003e implements Tree\u003cT\u003e { //2-3树是最简单的B树:最大key数量2,最大子节点数3,最小key数量2 private int minKeySize = 1; private int minChildrenSize = minKeySize + 1; private int maxKeySize = 2 * minKeySize; private int maxChildrenSize = maxKeySize + 1; private Node\u003cT\u003e root = null; private int size = 0; //默认2-3树 public BTree() { } //order:非根节点最少key数量 public BTree(int order) { this.minKeySize = order; this.minChildrenSize = minKeySize + 1; this.maxKeySize = 2 * minKeySize; this.maxChildrenSize = maxKeySize + 1; } public BTree\u003cT\u003e appendAdd(T value) throws Exception { boolean added = add(value); if (added) { return this; } else { throw new Exception(\"add \" + value + \" error\"); } } @Override public boolean add(T value) { if (root == null) { root = new Node\u003cT\u003e(null, maxKeySize, maxChildrenSize); root.addKey(value); } else { Node\u003cT\u003e node = root; while (node != null) { //没有子节点就在当前节点插入 if (node.numberOfChildren() == 0) { node.addKey(value); if (node.numberOfKeys() \u003c= maxKeySize) { break; } //key数量已满，需要分裂 split(node); break; } //否则，按有序的规则查找该插入的节点 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c= 0) { node = node.getChild(0); continue; } int numberOfKeys = node.numberOfKeys(); int last = numberOfKeys - 1; T greater = node.getKey(last); if (value.compareTo(greater) \u003e 0) { node = node.getChild(numberOfKeys); continue; } for (int i = 1; i \u003c node.numberOfKeys(); i++) { T prev = node.getKey(i - 1); T next = node.getKey(i); if (value.compareTo(prev) \u003e 0 \u0026\u0026 value.compareTo(next) \u003c= 0) { node = node.getChild(i); break; } } } } size++; return true; } @Override public T remove(T value) { T removed = null; Node\u003cT\u003e node = this.getNode(value); removed = remove(value, node); return removed; } @Override public boolean contains(T value) { Node\u003cT\u003e node = getNode(value); return node != null; } @Override public void clear() { root = null; size = 0; } @Override public int size() { return size; } @Override public boolean validate() { if (root == null) { return true; } return validateNode(root); } @Override public Collection\u003cT\u003e toCollection() { return new JavaCompatibleBTree\u003c\u003e(this); } @Override public String toString() { return TreePrinter.getString(this); } /** * 获取目标值所在节点 * @param value 要查找的值 * @return 目标值所在节点 */ private Node\u003cT\u003e getNode(T value) { Node\u003cT\u003e node = root; while (node != null) { //尝试是否比节点最小值小 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c 0) { if (node.numberOfChildren() \u003e 0) { node = node.getChild(0); } else { node = null; } continue; } //尝试是否比节点最大值大 int numberOfKeys = node.numberOfKeys(); int lastIndex = numberOfKeys - 1; T greater = node.getKey(lastIndex); if (value.compareTo(greater) \u003e 0) { if (node.numberOfChildren() \u003e numberOfKeys) { node = node.getChild(numberOfKeys); } else { node = null; } continue; } //不满足极大极小情况,在中间值中比较 for (int i = 0; i \u003c numberOfKeys; i++) { T currentValue = node.getKey(i); if (currentValue.compareTo(value) == 0) { return node; } int next = i + 1; if (next \u003c= lastIndex) { T nextValue = node.getKey(next); //目标值介于第i与第i+1个key之间时,在第i+1个子节点(如果有)中继续查找 if (value.compareTo(currentValue) \u003e 0 \u0026\u0026 value.compareTo(nextValue) \u003c 0) { if (next \u003c node.numberOfChildren()) { node = node.getChild(next); break; } return null; } } } } return null; } /** * 从节点中删除值 * @param value 要删除的值 * @param node 要删除的值所在节点 * @return true-删除成功 */ private T remove(T value, Node\u003cT\u003e node) { if (node == null) { return null; } T removed = null; int index = node.indexOf(value); removed = node.removeKey(index); //叶子节点元素的删除:1.直接删除 2.兄弟节点借值 3.合并兄弟节点(之一)与父节点key if (node.numberOfChildren() == 0) { if (node.parent != null \u0026\u0026 node.numberOfKeys() \u003c minKeySize) { this.combined(node); } else if (node.parent == n","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 B+树都插入根B树类似,需要注意以下两点 内部节点分裂时,key不重复 子节点分裂时,分裂的中间值在右子节点重复 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:3:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key仅在叶子节点 节点key数量大于最小key数量 直接删除 节点只有最小key数量 删除该key，从直接兄弟节点借一个key，将兄弟节点的中间key移到父节点 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key存在于内部节点和叶子节点 key数量大于最小key数量 直接删除内部节点和叶子节点的key，用有序后继填充内部节点删除的位置 只有最小key数量且key所在位置相邻 删除该key,从直接兄弟节点借一个值，填充内部节点删除的位置 只有最小key数量且key所在位置不相邻 删除该key,合并兄弟节点，用有序后续填充内部节点删除的位置 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["编程"],"content":"1. 枚举类型的介绍 枚举类型是一种特殊的数据类型，它使得变量成为一组预定义常量。所以在需要表示一组固定常量时应尽量使用枚举类型。通过关键字enum来定义枚举类，它和普通类一样可以有构造器、成员变量、方法。 1.1 枚举类的特性 所有的枚举类都隐式的继承java.lang.Enum，Java不允许多继承，所以枚举类不能再继承其他任何类，但可以实现接口 枚举类被隐式地声明为final，所以也不能被其他任何类继承 枚举类型的构造函数修饰符必须是private。定义枚举常量时会自动调用，不能自己调用枚举的构造函数 枚举类的实例必须在第一行列出，并且枚举值默认被public static final修饰 编译时编译器会自动帮我们添加两个静态方法values()和valueOf() 1.2 枚举类的原理 下面我们定义了一个枚举类并让它实现Info接口，这样可以让枚举值提供不同的实现，当然也可以在枚举类里面定义一个抽象方法，这样枚举值也必须实现此抽象方法才可，效果都一样。 public enum Season implements Info{ SPRING(\"spring\",\"春暖花开\"){ public void show(){ System.out.println(\"春天在哪里\"); } }, SUMMER(\"summer\",\"夏日炎炎\"){ public void show(){ System.out.println(\"生如夏花\"); } }, AUTUMN(\"autumn\",\"秋高气爽\"){ public void show(){ System.out.println(\"秋\"); } }, WINTER(\"winter\",\"白雪茫茫\"){ public void show(){ System.out.println(\"冷\"); } }; private final String seasonName; private final String seasonDesc; Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } } 可以看到该枚举类编译后的class文件，其中还包括了四个枚举值对应的class文件，而且其后还带有序号。在枚举实例创建时会给每个枚举值指定一个整形常量值（序号），若没有显示指定，则 整形常量值从0开始递增。这其实是与父类Enum有关，后面会介绍。 下面是利用javap工具查看Season.java经过编译后的字节码（请忽略乱码–.–）: \"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javap.exe\" -c pre.chl.enums.Season Compiled from \"Season.java\" public abstract class pre.chl.enums.Season extends java.lang.Enum\u003cpre.chl.enums.Season\u003e implements pre.chl.enums.Info { public static final pre.chl.enums.Season SPRING; public static final pre.chl.enums.Season SUMMER; public static final pre.chl.enums.Season AUTUMN; public static final pre.chl.enums.Season WINTER; public static pre.chl.enums.Season[] values(); Code: 0: getstatic #2 // Field $VALUES:[Lpre/chl/enums/Season; 3: invokevirtual #3 // Method \"[Lpre/chl/enums/Season;\".clone:()Ljava/lang/Object; 6: checkcast #4 // class \"[Lpre/chl/enums/Season;\" 9: areturn public static pre.chl.enums.Season valueOf(java.lang.String); Code: 0: ldc #5 // class pre/chl/enums/Season 2: aload_0 3: invokestatic #6 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #5 // class pre/chl/enums/Season 9: areturn public java.lang.String getSeasonName(); Code: 0: aload_0 1: getfield #8 // Field seasonName:Ljava/lang/String; 4: areturn public java.lang.String getSeasonDesc(); Code: 0: aload_0 1: getfield #9 // Field seasonDesc:Ljava/lang/String; 4: areturn public java.lang.String toString(); Code: 0: new #10 // class java/lang/StringBuilder 3: dup 4: invokespecial #11 // Method java/lang/StringBuilder.\"\u003cinit\u003e\":()V 7: ldc #12 // String Season{seasonName=' 9: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 12: aload_0 13: getfield #8 // Field seasonName:Ljava/lang/String; 16: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: bipush 39 21: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 24: ldc #15 // String , seasonDesc=' 26: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: aload_0 30: getfield #9 // Field seasonDesc:Ljava/lang/String; 33: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 36: bipush 39 38: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 41: bipush 125 43: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 46: invokevirtual #16 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 49: areturn pre.chl.enums.Season(java.lang.String, int, java.lang.String, java.lang.String, pre.chl.enums.Season$1); Code: 0: aload_0 1: aload_1 2: iload_2 3: aload_3 4: aload 4 6: invokespecial #1 // Method \"\u003cinit\u003e","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:1","tags":["Java"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"2. 枚举类的使用 2.1 定义 public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } 枚举值之间使用\",“分隔，如果后面没有属性或方法，最后加不加”;“都行。但如果有就一定要加”;\" public enum PurOrderSplitEnum { NORELEASEERPBILLCOUNT(\"1\", \"待发布\"), RELEASEERPBILLCOUNT(\"2\", \"待买方确认\"), PURCONFIRMINGCOUNT(\"3\", \"买方变更中\"); private String code; private String name; public static Map\u003cString, String\u003e code2name = new HashMap(); public static Map\u003cString, String\u003e code2Muname = new HashMap(); private PurOrderSplitEnum(String code, String name) { this.code = code; this.name = name; } public String getCode() { return this.code; } public String getName() { return this.name; } static { code2name.put(NORELEASEERPBILLCOUNT.getCode(), NORELEASEERPBILLCOUNT.getName()); code2name.put(RELEASEERPBILLCOUNT.getCode(), RELEASEERPBILLCOUNT.getName()); code2name.put(PURCONFIRMINGCOUNT.getCode(), PURCONFIRMINGCOUNT.getName()); code2Muname.put(NORELEASEERPBILLCOUNT.getCode(), \"NORELEASEERPBILLCOUNT\"); code2Muname.put(RELEASEERPBILLCOUNT.getCode(), \"RELEASEERPBILLCOUNT\"); code2Muname.put(PURCONFIRMINGCOUNT.getCode(), \"PURCONFIRMINGCOUNT\"); } } 2.2 结合Switch 在switch中使用枚举，可以让我们的代码可读性更好 public class EnumTest { Day day; public EnumTest(Day day) { this.day = day; } public void tellItLikeItIs() { switch (day) { case MONDAY: System.out.println(\"周一还行吧\"); break; case FRIDAY: System.out.println(\"周五很nice\"); break; case SATURDAY: case SUNDAY: System.out.println(\"周末超级棒\"); break; default: System.out.println(\"额....\"); break; } } public static void main(String[] args) { EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); EnumTest fifthDay = new EnumTest(Day.FRIDAY); fifthDay.tellItLikeItIs(); EnumTest sixthDay = new EnumTest(Day.SATURDAY); sixthDay.tellItLikeItIs(); EnumTest seventhDay = new EnumTest(Day.SUNDAY); seventhDay.tellItLikeItIs(); } //输出结果 /* 周一还行吧 额.... 周五很nice 周末超级棒 周末超级棒 */ 2.3 valueOf方法 把字符串转成对应类型的枚举值，如： String str = \"SPRING\"; Season season2 = Season.valueOf(str); //Season season2 = Season.valueOf(Season.class,str);跟上面是等价的 System.out.println(season2 == season1);//true 2.4 values()和其他方法 values()方法可以返回所有定义的枚举值，name()方法返回的是枚举的名称，不是枚举值里面的属性名称，这里需要注意一下。 Season season1 = Season.SPRING; for(Season season:Season.values()){ System.out.println(season); } season1.show(); System.out.println(season1.name()); System.out.println(\"SPIRNG的序号:\" + season1.ordinal()); //输出结果 /* Season{seasonName='spring', seasonDesc='春暖花开'} Season{seasonName='summer', seasonDesc='夏日炎炎'} Season{seasonName='autumn', seasonDesc='秋高气爽'} Season{seasonName='winter', seasonDesc='白雪茫茫'} 春天在哪里 SPRING 0 */ 2.5 使用接口组织枚举 在接口中定义枚举类，可以将数据分组。 public interface Animal { enum Dog implements Animal { HUSKY,GOLDEN_RETRIEVER,ALASKAN_MALAMUTE } enum Cat implements Animal { PERSIAN,RAGDOLL,BIRMAN } } // Animal dog = Animal.Dog.ALASKAN_MALAMUTE; // Animal cat = Animal.Cat.BIRMAN; 2.6 EnumSet和EnumMap Set类型是枚举集或Map的key是枚举值时，使用这两者将会更加高效。这里只摘取Java API文档的部分说明，详细的方法大家可以自己查找文档。 EnumMap 用于枚举类型键的专用Map实现。 枚举映射中的所有键必须来自创建映射时显式或隐式指定的单个枚举类型。 枚举映射在内部表示为数组。 这种表现非常紧凑和高效。 枚举映射按其键的自然顺序（枚举常量的声明顺序）维护。 这反映在集合视图（keySet（），entrySet（）和values（））返回的迭代器中。 集合视图返回的迭代器非常一致：它们永远不会抛出ConcurrentModificationException，它们可能会也可能不会显示迭代进行过程中对映射所做的任何修改的影响。 Key不允许为null。 尝试插入null将抛出NullPointerException。 但是，尝试测试是否存在空键或删除空键将正常运行。 value允许为null。 与大多数集合实现一样，EnumMap不同步。 如果多个线程同时访问枚举映射，并且至少有一个线程修改了映射，则应该在外部进行同步。 这通常通过在自然封装枚举映射的某个对象上同步来完成。 如果不存在此类对象，则应使用Collections.synchronizedMap（java.util.Map \u003cK，V\u003e）方法“包装”映射。 这最好在创建时完成，以防止意外的不同步访问： Map \u003cEnumKey，V\u003e m= Collections.synchronizedMap（new EnumMap \u003cEnumKey，V\u003e（...））; 说明：所有基本操作都在恒定时间内执行。 它们很可能（虽然不能保证）比它们对应的HashMap更快。 EnumSet 用于枚举类型的专用Set实现。 枚举集中的所有元素必须来自单个枚举类型，该类型在创建集时显式或隐式指定。 枚举集在内部表示为位向量。 这种表现非常紧凑和高效。 这个类的空间和时间性能应该足够好，以允许它作为传统的基于int的“位标志”的高性能、类型安全的替代品。 如果它们的参数也是枚举集，即使批量操作（例如containsAll和retainAll）也应该非常快速地运行。 迭代器方法返回的迭代器以其自然顺序（枚举常量声明的顺序）遍历元素。 返回的迭代器是弱一致的：它永远不会抛出ConcurrentModificationException，它可能会也可能不会显示迭代进行过程中对集合所做的任何修改的影响。 不允许使用空元素。 尝试插入null元素将抛出NullPointerException","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:2","tags":["Java"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["网络安全"],"content":"1. XSS简介 跨站脚本(Cross Site Script)为了避免与CSS混淆,简称XSS。XSS是指攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，在输入框添加一些代码，嵌入到web页面中，使别的用户访问会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。XSS又分为反射型、存储型和DOM-Based型。 XSS的危害包括： 盗取用户Cookie DDOS客户端浏览器 盗窃企业重要的具有商业价值的资料 爆发web2.0蠕虫 强制发送电子邮件 网站挂马，钓鱼攻击 劫持用户web行为甚至渗透内网 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:1:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"2. 原理 （1）反射型 服务端返回脚本，客户端执行。如URL注入非法脚本，然后诱导用户点击该链接，但是一般浏览器都会有基本防御措施，自带拦截过滤；服务端返回的富文本中包含非法脚本，被直接展示。 （2）存储型 后台被动存储了非法脚本，并且前端直接展示。如发帖或留言中发出包含恶意代码的内容,其他用户访问该内容后,满足特定条件即触发,这种需要后台不过滤信息,并且前端展示时也不过滤信息。 （3）DOM-Based型 基于DOM或本地的XSS攻击。如wifi流量劫持、DNS劫持并直接返回钓鱼页面。本质是需要更改DOM，再排除自己攻击自己。某些反射型的攻击也能造成这个后果-通过url控制DOM。在传统的XSS中，恶意JavaScript脚本在页面加载时执行，而在基于DOM的XSS中，恶意JavaScript脚本在页面加载后的某个时刻执行。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:2:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"3.自动化XSS Browser Exploitation Framework(BeEF),是目前强大的浏览器开源渗透测试框架,通过XSS漏洞配合JS脚本和Metasploit进行渗透。它是基于Ruby编写，支持图形化界面，操作简单。 Kali linux已经自带BeEF,另外我使用一个开源的靶机OWASP Broken Web Apps来练习。 在靶机的低安全级别下执行一个存储型的XSS： 然后使用win10的Google浏览器访问靶机的相应被注入脚本的页面后，BeEF中的记录： 之后就可以使用beef控制用户的浏览器进行多种操作（比如钓鱼），但是这里并没有win10的记录，原因是chrome对该XSS进行了过滤。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:3:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"4. 如何预防 （1）编码，转义用户输入，编码可在前端和后端中进行。常见的如下图的HTML转义 但是编码并不适用所有情况，比如当用户需要提供一个URL或者编写用户配置文件时，对输入编码是不友好的，不应对用户的自定义配置做限制，所以需要使用验证。 （2）验证，过滤用户输入。有两种实现方式 分类策略，使用白名单或黑名单分类 验证结果，拒绝或删除不合法的输入 （3）CSP内容安全策略（CSP） CSP用于约束浏览器只能使用从可信来源下载的资源。资源是页面引用的脚本，样式表，图像或其他类型的文件。这样即使攻击者成功将恶意内容注入到网站，CSP也可以防止它被执行。 CSP可用于执行以下规则： 没有不受信任的来源。外部资源只能从一组明确定义的可信来源加载。 没有内联资源。不会评估内联JavaScript和CSS。 无法使用JavaScript eval函数。 Content‑Security‑Policy: script‑src 'self' scripts.example.com; media‑src 'none'; img‑src *; default‑src 'self' http://*.example.com 以上CSP表明脚本只能从提供页面的主机和scripts.example.com下载。 无法从任何地方下载音频和视频文件。可以从任何主机下载图像文件。 所有其他资源只能从提供该页面的主机和example.com的任何子域下载。 (4) 其他方法 Cookie设置http-only。http-only标志可以防止cookie被“读取”，但不能防止被“写”,已证明有些浏览器的http-only标记可以被JavaScript写入覆盖，而这种覆盖可能被攻击者利用发动session fixation攻击。 WAF,大多数使用规则匹配,也能被绕过。 X-XSS-Protection也有助于在一些浏览器中防止某些XSS，但在某些情况下可以被绕过。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:4:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["编程"],"content":"JMM(Java Memory Model),Java内存模型,它是一种Java虚拟机需要遵守的规范，定义了线程间如何在内存中正确地交互。JDK5以后的JMM规范在JSR-133中详细列出。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"1. 内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"1.1 为什么需要内存模型 多线程编程的困难在于很难对程序进行调式，如果控制不好，就会产生意料之外的结果。对于传统的单核CPU来说，由于是并发执行，即同一时刻只有一个线程在执行，所以一般不会出现数据的访问冲突。这也不是绝对的，单核多线程场景下，如果允许抢占式调度，仍存在线程安全问题。当前的处理器架构大多是多核+多级缓存+主存的模式，这样在多线程场景下就存在数据竞争从而造成缓存不一致的问题。另外CPU可能会对程序进行优化，进行指令重排序，只要重排后程序的语义没有发生变化，指令重排就是有可能发生的（编译器和JVM也存在指令重排），但这有时会让多线程执行的结果出乎意料。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:1","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"1.2 什么是内存模型 对处理器来说，内存模型定义了充分必要条件，以知道其他处理器对内存的写入对当前处理器可见，而当前处理器的写入对其他处理器可见。一些处理器使用强内存模型，即所有处理器在任何给定的内存位置上始终能看到完全相同的值,但这也不是绝对的,某些时候也需要使用特殊指令(称为内存屏障)来完成。其他处理器使用弱内存模型，需要内存屏障来刷新或使本地处理器缓存失效，以便查看其他处理器的写操作或使此处理器的写操作对其他处理器可见。这些内存屏障通常在lock和unlock时执行；对于使用高级语言的程序员来说，它们是不可见的。处理器的设计趋势是鼓励使用弱内存模型,因为它们的规范具有更强的可伸缩性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:2","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"1.3 其他语言有内存模型吗 大多数其他编程语言（如C和C ++）的设计并未直接支持多线程。 这些语言针对编译器和体系结构中发生的各种重排序提供的保护很大程度上取决于所使用的线程库（例如pthread），所使用的编译器以及运行代码的平台所提供的保证。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:3","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.Java内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.1 简介 Java内存模型是建立在内存模型之上的，它回答了当读取一个确定的字段时什么样的值是可见的。它将一个Java程序分解成若干动作（actions）并且为这些动作分配一个顺序。如果分配的这些顺序中能在对一个字段的写操作(write actions)和读操作(read actions)间形成一个叫happens-before的关系,那么Java内存模型保证了读操作将返回一个正确的值。 JMM规定所有实例域、静态域和数组元素存储在JVM内存模型的的堆中，堆内存在线程间是共享的。局部变量和异常处理器参数不会共享，他们不存在内存可见性问题。每个线程创建时JVM都会为其创建一个工作内存(栈空间),工作内存是每个线程的私有数据区域,线程对变量的操作必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作内存空间,然后对变量进行操作,操作完成后再将变量写回主内存`,不能直接操作主内存中的变量,各个线程中的工作内存中存储着主内存中的变量副本拷贝,因此线程间的通信必须通过主内存来完成。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:1","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.2 代码优化问题 上面一段代码,模拟了两个线程。期望可能是thread1执行一次count++,thread2修改flag的值,然后thread1退出循环。但是在未做同步控制的情况下多线程的执行情况是无法预料的。还存在一个很重要的问题，那就是编译器优化（这里编译器可以是Java编译器如JIT，JVM，CPU）。 对于thread1，没有对flag的写操作，所以编译器认为flag的值总是true，就将flag直接改为true来提高程序运行速度，这种优化是被允许的，因为对于它本身而言没有改变程序语义。 对于thread2，没有要求对flag的值要刷回主存，编译器就可能优化为忽略对flag的写指令，因为不刷回主存的值改变只有线程自己可见。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:2","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.3 指令重排序问题 对上图中三条指令，我们期望是顺序执行，但某些编译器为了提高速度，很可能对指令重排序变成下面一种执行顺序。 再来看看下面的例子 处理器A 处理器B a = 1; // 写操作A1 b =2; //写操作B1 x = b; //读操作A2 y = a; //读操作B2 初始状态 a = b = 0 结果 x = y = 0 之所以会出现以上结果,是因为处理器对写读指令进行了重排序,如将顺序A1 -\u003e A2重排成A2 -\u003e A1。对写读的重排序在x86架构下是被允许的。下图是不同架构下支持的重排序类型，这解释了为什么相同的程序在不同的架构系统下会产生不同的结果，因为编译器可能对你的代码进行了不同的重排序。 另外重排序需要考虑到数据之间的依赖性，比如下面3条指令,3是不会排到指令1之前的,因为指令3依赖于指令1的数据x。 int x = 1; //1 int y = 2; //2 y = x * x; //3 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:3","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.4 可见性问题 观察以上代码，写线程在自己的工作内存中改变了x的值却并未来得及刷回主内存,这样读线程读取到的值仍然是旧值,读线程此时对写线程的操作不可见。Java为此提供了volatile关键字解决方案：只要用volatile修饰变量x,对x进行原子操作后,x的值将立马刷回主内存,这样保证了读线程对写线程的可见性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:4","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.5 原子性问题 Java中long型占8字节,也就是64位,如果在64位操作系统中执行以上代码不存在原子性问题,对foo的写操作一步完成,但是在32位操作系统中这种写操作就失去了原子性。32位操作系统中对foo的写操作分两步进行-分别对高32位和低32位进行写操作。在这种情况下就可能产生如下结果 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:5","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.6 Happens-before规则 Happens-before表示动作上的偏序关系，官方文档对于该规则的定义如下 大致翻译一下就是: 两个动作可以由happends-before关系排序,如果一个动作happens-before另一个动作,那么第一个动作的执行结果对后一个动作可见。两个操作之间存在happens-before关系，并不意味着必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。例如，在线程构造的对象的每个字段中写入默认值不需要在该线程的开始之前发生，只要没有读取操作就会观察到该事实。另外，当两个动作存在于不同的线程中时，也存在这种关系，此种情况下两者之间会存在一个消息传递机制。 happens-before的8条规则如下： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:6","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"2.7 实现 字段域 方法域 final synchronized(method/block) volatile java.util.concurrent.* volatile public class VolatileFieldsVisivility{ int a = 0; volatile int x = 0; public void writeThread(){ a = 1; //1 x = 1; //2 } public void readThread(){ int r2 = x; //3 int d1 = a; //4 } } 假设写线程执行完后,问读线程读变量a的值是1还是0还是不确定?答案是确定的1，即使变量a未用volatile修饰。由上面给出的happens-before规则可推得：1 happens-before 2, 2 happens-before 3 , 3 happens-before 4 –\u003e 1 happens-before 4(传递性),即读线程读a的时候一定能看到写线程的执行结果，简短来说就是当一个线程对volatile修饰的变量写入，并且读取时也是此变量时在他之前的所有写操作被保证对其他线程是可见的。值得注意的是,写读操作必须是原子性的,如果被volatile修饰的是long或者double,那么这个64位的变量不能被拆分存储。也就是说volatile保证了可见性和有序性,但不保证原子性。 由于篇幅过长,其他方式的实现我将在其他文章中单独抽出来分析。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:7","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["编程"],"content":"3. 总结 Java内存模型就是Java语言在内存模型上的实现，它是为了保证多线程场景下的原子性、可见性和有序性提出的规范。Java语言提供了volatile、synchronized、final关键字和java.util.concurrent.*并发编程包来实现这些规范,这些提供给程序员的原语和包屏蔽了和底层交互的细节,让程序员可以更方便快捷地编程。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["Java"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]