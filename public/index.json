[{"categories":["Java编程"],"content":"概述 泛型可以使得在编译期发现bug,从而增加代码稳定性。泛型使得在定义类、接口和方法时类型（类和接口）可以被参数化。就像方法声明中使用的形参，类型参数对于不同的输入可以重用代码。不同点在于形参的输入是值，类型参数的输入是类型。 使用泛型有诸多益处： 编译器强类型检查：Java编译器对泛型代码运行强类型检查，如果代码类型不安全则报错。修复编译器错误总比修复运行时错误简单 消除转换： 下面代码端需要转换 List list = new ArrayList(); list.add(\"hello\"); String s = (String) list.get(0); 使用泛型则不需要转换 List\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"hello\"); String s = list.get(0); // no cast 提供实现通用算法的能力:通过泛型,程序员能实现集合上不同类型的通用算法,这些算法可以自定义,类型安全且更易读 泛型类型 泛型类型是类型参数化的泛型类或泛型接口。 以一个示例展示泛型的使用，下面非泛型的Box类适用于任何类型的对象 public class Box { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; } } 因为它的方法接受或返回一个Object对象,所以你可以传入除原始类型外的任何对象。但在运行时无法验证该类如何被使用。一部分代码可能使用Integer并期望输出Integer，同时另一部分代码可能错误地传入String,这将导致运行时错误。 泛型类的定义格式如下： class name\u003cT1, T2, ..., Tn\u003e { /* ... */ } 将泛型应用到Box类上 /** * Generic version of the Box class. * @param \u003cT\u003e the type of the value being boxed */ public class Box\u003cT\u003e { // T stands for \"Type\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 类型变量可以是任何非原始类型:任意类、接口、数组甚至是其它类型变量。 类型参数命名约定 约定类型参数命名是单个大写字母，常见的类型参数名称如下： E-Element(在Java集合框架中常用) K-Key N-Number T-Type V-Value S,U,V等 调用并实例化泛型类型 要使用泛型类,必须以具体的类型值代替泛型定义。如使用Box类Box\u003cInteger\u003e integerBox;可以把泛型类调用类比普通方法调用,只不过传递的是类型参数（就像上面传递的是Integer）。 type paramaeter与type argument术语: 编码时,type argument用来创建一个参数化的类型。如Foo\u003cT\u003e中的T是type paramaeter，Foo\u003cString\u003e中的String是type argument 泛型类型的调用也叫类型参数化。泛型类的实例化如下例子: Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); //java 7之后,编译器可以从上下文中确定或推断类型参数 Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); 多类型参数 public interface Pair\u003cK, V\u003e { public K getKey(); public V getValue(); } public class OrderedPair\u003cK, V\u003e implements Pair\u003cK, V\u003e { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } OrderedPair\u003cString, Integer\u003e p1 = new OrderedPair\u003c\u003e(\"Even\", 8);//自动装箱使得可以传入原始类型 OrderedPair\u003cString, String\u003e p2 = new OrderedPair\u003c\u003e(\"hello\", \"world\"); 参数化类型 可以将类型参数(如K,V)替换为参数化类型(如List\u003cString\u003e) OrderedPair\u003cString, Box\u003cInteger\u003e\u003e p = new OrderedPair\u003c\u003e(\"primes\", new Box\u003cInteger\u003e(...)); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:0:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"原始类型 原始类型是不带任何类型参数的泛型类或泛型接口。 public class Box\u003cT\u003e { public void set(T t) { /* ... */ } // ... } //参数化定义 Box\u003cInteger\u003e intBox = new Box\u003c\u003e(); //Box\u003cT\u003e的原始类型 Box rawBox = new Box(); Box是Box\u003cT\u003e的原始类型,但是非泛型类或接口不是原始类型。 原始类型在旧版代码中出现，因为那是许多API类（像Collections）不支持泛型。当使用原始类型时，实际上是一种预泛型行为:Box的f泛型参数被参数化为Object。为了向后兼容，将参数化类型赋值给原始类型是允许的： Box\u003cString\u003e stringBox = new Box\u003c\u003e(); Box rawBox = stringBox; // OK 但是反过来你会得到一个警告: Box rawBox = new Box(); // rawBox is a raw type of Box\u003cT\u003e Box\u003cInteger\u003e intBox = rawBox; // warning: unchecked conversion 如果你用原始类型来调用泛型类的方法同样会得到警告: //这段代码不会报错,stringBox在运行时存储的值为\u003cInteger\u003e类型 Box\u003cString\u003e stringBox = new Box\u003c\u003e(); Box rawBox = stringBox; rawBox.set(8); // warning: unchecked invocation to set(T) 这表明原始类型绕过了泛型类型检查 未受检错误信息 当在旧版本代码中使用泛型代码时,可能出现以下警告信息: Note: Example.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 这通常在旧版API中使用原始类型时出现： public class WarningDemo { public static void main(String[] args){ Box\u003cInteger\u003e bi; bi = createBox(); } static Box createBox(){ return new Box(); } } “unchecked\"意味着编译器没有足够的类型信息执行所有的类型检查来确保类型安全。使用-Xlint:unchecked重新编译来查看所有'“unchecked\"警告： WarningDemo.java:4: warning: [unchecked] unchecked conversion found : Box required: Box\u003cjava.lang.Integer\u003e bi = createBox(); ^ 1 warning 可以用-Xlint:-unchecked禁用未受检警告；@SuppressWarnings(\"unchecked\")注解会抑制未受检警告。 泛型方法 泛型方法是引入自己的类型参数的方法。与声明泛型类型相似，但是其类型参数的作用域限制在方法内。静态、非静态泛型方法以及泛型类构造器都合法。 泛型方法的语法包含出现在方法返回类型前的类型参数列表。 public class Util { public static \u003cK, V\u003e boolean compare(Pair\u003cK, V\u003e p1, Pair\u003cK, V\u003e p2) { return p1.getKey().equals(p2.getKey()) \u0026\u0026 p1.getValue().equals(p2.getValue()); } } public class Pair\u003cK, V\u003e { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } 泛型方法的调用如下: Pair\u003cInteger, String\u003e p1 = new Pair\u003c\u003e(1, \"apple\"); Pair\u003cInteger, String\u003e p2 = new Pair\u003c\u003e(2, \"pear\"); boolean same = Util.\u003cInteger, String\u003ecompare(p1, p2); 当省略明确的类型时,编译器将推断具体的类型: Pair\u003cInteger, String\u003e p1 = new Pair\u003c\u003e(1, \"apple\"); Pair\u003cInteger, String\u003e p2 = new Pair\u003c\u003e(2, \"pear\"); boolean same = Util.compare(p1, p2); 边界类型参数 如果我们想限制作为类型参数的参数化类型,如一个针对数字操作的方法仅接受Number及其子类,可以使用有界类型参数。 要声明有界类型参数，列出类型参数名称，后面加上extends关键字，然后是它的上界。在这种情况下，extends是广义的意味着\"extends(类)“或\"implements(接口)\"。 public class Box\u003cT\u003e { private T t; public void set(T t) { this.t = t; } public T get() { return t; } public \u003cU extends Number\u003e void inspect(U u){ System.out.println(\"T: \" + t.getClass().getName()); System.out.println(\"U: \" + u.getClass().getName()); } public static void main(String[] args) { Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); integerBox.set(new Integer(10)); //使用了有界泛型参数,编译器失败 integerBox.inspect(\"some text\"); // error: this is still String! } } 有界泛型参数除了限制类型外,你还可以用起实例调用边界类型的方法: public class NaturalNumber\u003cT extends Integer\u003e { private T n; public NaturalNumber(T n) { this.n = n; } public boolean isEven() { return n.intValue() % 2 == 0; } // ... } 多边界 一个类型参数可以有多个边界: \u003cT extends B1 \u0026 B2 \u0026 B3\u003e 有多个边界的类型变量是所有边界类型的子类型。如果有一个边界是类，它必须先声明(否则编译不通过)，例如： Class A { /* ... */ } interface B { /* ... */ } interface C { /* ... */ } class D \u003cT extends A \u0026 B \u0026 C\u003e { /* ... */ } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:1:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的边界类型参数 有界类型参数是实现泛型算法的关键。下面的泛型使用会出现编译错误： public static \u003cT\u003e int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e \u003e elem) // compiler error ++count; return count; } 因为”\u003e“操作符只能运用于原始类型,可以使用以Comparable\u003cT\u003e为上界的类型参数修复: public static \u003cT extends Comparable\u003cT\u003e\u003e int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) \u003e 0) ++count; return count; } 泛型中的继承和子类型 把一种类型的对象赋值给另一种类型的对象在某些情况下是可行的。例如，你可以把Integer的对象赋值给Object的，因为Object是Integer的超类： Object someObject = new Object(); Integer someInteger = new Integer(10); someObject = someInteger; // OK 因为Integer也是Number的子类型,所以以下代码也合法: public void someMethod(Number n) { /* ... */ } someMethod(new Integer(10)); // OK someMethod(new Double(10.1)); // OK 泛型也适用以上的赋值法则: Box\u003cNumber\u003e box = new Box\u003cNumber\u003e(); box.add(new Integer(10)); // OK box.add(new Double(10.1)); // OK 考虑以下代码: public void boxTest(Box\u003cNumber\u003e n) { /* ... */ } 该方法不能接受Box\u003cInteger\u003e或Box\u003cDouble\u003e为入参,因为它们都不是Box\u003cNumber\u003e的子类型。 给定类型A和B，MyClass\u003cA\u003e和MyClass\u003cB\u003e没有从属关系,它们的父类都是Object。 泛型类和其子类 你可以通过继承或实现来子类化一个泛型类或接口。 以Collections类举例,ArrayList\u003cE\u003e实现List\u003cE\u003e,List\u003cE\u003e继承Collection\u003cE\u003e。 自定义一个list接口PayloadList: interface PayloadList\u003cE,P\u003e extends List\u003cE\u003e { void setPayload(int index, P val); ... } 下列参数化的PayloadList是List\u003cString\u003e的子类型: PayloadList\u003cString,String\u003e PayloadList\u003cString,Integer\u003e PayloadList\u003cString,Exception\u003e 类型推断 类型推断是Java编译器确定具体的类型参数来使方法调用和声明可用的能力。类型推断算法确定参数的类型，该类型赋值给返回值或直接返回。最后，推断算法找到适用于所有参数的最合适的类型。 下面的例子，推断确定了传递给pick方法的两个参数是Serializable类型。 static \u003cT\u003e T pick(T a1, T a2) { return a2; } Serializable s = pick(\"d\", new ArrayList\u003cString\u003e()); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:2:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的类型推断 类型推断可以让你像调用普通方法一样调用泛型方法。看看下面的例子： public class BoxDemo { public static \u003cU\u003e void addBox(U u, java.util.List\u003cBox\u003cU\u003e\u003e boxes) { Box\u003cU\u003e box = new Box\u003c\u003e(); box.set(u); boxes.add(box); } public static \u003cU\u003e void outputBoxes(java.util.List\u003cBox\u003cU\u003e\u003e boxes) { int counter = 0; for (Box\u003cU\u003e box: boxes) { U boxContents = box.get(); System.out.println(\"Box #\" + counter + \" contains [\" + boxContents.toString() + \"]\"); counter++; } } public static void main(String[] args) { java.util.ArrayList\u003cBox\u003cInteger\u003e\u003e listOfIntegerBoxes = new java.util.ArrayList\u003c\u003e(); BoxDemo.\u003cInteger\u003eaddBox(Integer.valueOf(10), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes); BoxDemo.outputBoxes(listOfIntegerBoxes); } } //输出 Box #0 contains [10] Box #1 contains [20] Box #2 contains [30] addBox方法定义了一个名为U的类型参数,通常Java编译器能推断调用的泛型方法的类型参数。所以多数情况下不用具体说明。例如，调用addBox方法,你可以使用具体的类型参数: BoxDemo.\u003cInteger\u003eaddBox(Integer.valueOf(10), listOfIntegerBoxes); 相应的,如果你省略类型参数,Java编译器从方法参数中自动推断类型参数的类型为Integer: BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:3:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"实例化泛型类中的类型推断 泛型类实例化时,你可以在实例化的\u003c\u003e符号中省略类型参数,但是你不能省略\u003c\u003e符号,否则会被认为是原始类型: Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap\u003cString, List\u003cString\u003e\u003e(); //省略类型参数 Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap\u003c\u003e(); //未受检警告 Map\u003cString, List\u003cString\u003e\u003e myMap = new HashMap(); // unchecked conversion warning ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:4:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型构造器中的类型推断 泛型构造器可以存在于泛型类和非泛型类中，泛型构造器可以有自己的形式类型参数。如： class MyClass\u003cX\u003e { \u003cT\u003e MyClass(T t) { // ... } } 考虑下面MyClass的实例化: MyClass\u003cInteger\u003e myObject1 = new MyClass\u003cInteger\u003e(\"\") //省略版 MyClass\u003cInteger\u003e myObject2 = new MyClass\u003c\u003e(\"\"); 该语句定义了参数化类型的MyClass\u003cInteger\u003e,它表明类型参数X的类型是Integer。同时，编译器推断类型参数T的类型是String。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:5:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"目标类型 Java编译器利用目标输入来判断泛型方法调用的类型参数。表达式的目标类型是Java编译器期望的数据类型，具体取决于表达式出现的位置。考虑Collections.emptyList方法，其定义如下： static \u003cT\u003e List\u003cT\u003e emptyList(); 考虑下面的赋值语句: List\u003cString\u003e listOne = Collections.emptyList(); 该表达式期望一个List\u003cString\u003e的实例,这种数据类型是目标类型。因为emptyList方法返回List\u003cT\u003e,编译器推断类型参数T必须是String。这在Java7和Java8中都适用。 但以下例子存在不同： void processStringList(List\u003cString\u003e stringList) { // process stringList } //这在Java7中无法编译,因为List\u003cT\u003e在Java7中认为需要List\u003cObject\u003e processStringList(Collections.emptyList()); //在Java7中可以编译通过 processStringList(Collections.\u003cString\u003eemptyList()); 通配符 泛型代码中,”?“叫作通配符，代表着一种未知类型。通配符可以在众多场景中使用：作为从参数类型、字段或者本地变量；有时甚至可以是返回类型。通配符不能用在泛型方法调用的类型参数、泛型类实例创建或超类。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:6:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"上界通配符 你可以使用上界通配符放大变量的限制。例如你想写一个能在List\u003cInteger\u003e中运行的方法,就可以使用上界通配符实现。 使用如\u003c? extends A\u003e声明。在这种情况下，extends是广义的意味着\"extends(类)“或\"implements(接口)\"。 例如： public static void process(List\u003c? extends Foo\u003e list) { /* ... */ } public static void process(List\u003c? extends Foo\u003e list) { for (Foo elem : list) { // elem可以使用任何定义在Foo类中的方法。 } } public static double sumOfList(List\u003c? extends Number\u003e list) { double s = 0.0; for (Number n : list) s += n.doubleValue(); return s; } List\u003cDouble\u003e ld = Arrays.asList(1.2, 2.3, 3.5); System.out.println(\"sum = \" + sumOfList(ld));//sum=7.0 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:7:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"无界通配符 无界通配符如:List\u003c?\u003e意为未知类型的列表。有两种场景适用无界通配符: 如果你在编写一个能用Object类提供的方法实现的方法 当代码使用了泛型类中不依赖于类型参数的方法，例如List.size或List.clear。Class\u003c?\u003e就经常被使用,因为Class\u003cT\u003e中的多数方法不依赖T。 考虑下面的printList方法: public static void printList(List\u003cObject\u003e list) { for (Object elem : list) System.out.println(elem + \" \"); System.out.println(); } printList并不能打印任何类型的列表,它仅打印Object实例。因为像例如List\u003cInteger\u003e不是List\u003cObject\u003e的子类型。使用无界通配符可实现打印任意类型列表： public static void printList(List\u003c?\u003e list) { for (Object elem: list) System.out.print(elem + \" \"); System.out.println(); } List\u003cInteger\u003e li = Arrays.asList(1, 2, 3); List\u003cString\u003e ls = Arrays.asList(\"one\", \"two\", \"three\"); printList(li); printList(ls); List\u003cObject\u003e与List\u003c?\u003e是不同的,你可以往List\u003cObject\u003e插入Object或任意Object的子类型,但你仅能插入null到List\u003c?\u003e。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:8:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"下界通配符 下界通配符将未知类型限定为特定类型或该类型的超类,使用\u003c? super A\u003e声明。下界通配符与上界通配符不能同时使用。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:9:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"通配符和子类型 可以使用通配符创建泛型中的类型关系,尽管List\u003cInteger\u003e和List\u003cNumber\u003e没有关系,但是它们的父类型都是List\u003c?\u003e。 List\u003c? extends Integer\u003e intList = new ArrayList\u003c\u003e(); List\u003c? extends Number\u003e numList = intList; // OK. List\u003c? extends Integer\u003e is a subtype of List\u003c? extends Number\u003e 下图显示了几个List类之间的关系: ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:10:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"通配符捕获和辅助方法 有时编译器会推断通配符的类型,这种场景叫通配符捕获。 下面的WildcardError类在编译时会产生一个捕获错误: import java.util.List; public class WildcardError { void foo(List\u003c?\u003e i) { i.set(0, i.get(0)); } } //Java7 WildcardError.java:6: error: method set in interface List\u003cE\u003e cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 1 error 你可以通过编写一个私有的辅助方法来捕获通配符。 public class WildcardFixed { void foo(List\u003c?\u003e i) { fooHelper(i); } // Helper method created so that the wildcard can be captured // through type inference. //通过该方法,编译器推断T就是被捕获的CAP#1变量的类型 private \u003cT\u003e void fooHelper(List\u003cT\u003e l) { l.set(0, l.get(0)); } } 约定辅助方法命名为originalMethodNameHelper（原方法名+Helper）。 再看一个更复杂的例子： import java.util.List; public class WildcardErrorBad { void swapFirst(List\u003c? extends Number\u003e l1, List\u003c? extends Number\u003e l2) { Number temp = l1.get(0); l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, // got a CAP#2 extends Number; // same bound, but different types l2.set(0, temp); // expected a CAP#1 extends Number, // got a Number } } List\u003cInteger\u003e li = Arrays.asList(1, 2, 3); List\u003cDouble\u003e ld = Arrays.asList(10.10, 20.20, 30.30); //这种情况没有辅助方法可以解决,因为把Double值添加到Integer列表中就是语法错误的 swapFirst(li, ld); // WildcardErrorBad.java:7: error: method set in interface List\u003cE\u003e cannot be applied to given types; l1.set(0, l2.get(0)); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number WildcardErrorBad.java:10: error: method set in interface List\u003cE\u003e cannot be applied to given types; l2.set(0, temp); // expected a CAP#1 extends Number, ^ required: int,CAP#1 found: int,Number reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number WildcardErrorBad.java:15: error: method set in interface List\u003cE\u003e cannot be applied to given types; i.set(0, i.get(0)); ^ required: int,CAP#1 found: int,Object reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion where E is a type-variable: E extends Object declared in interface List where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 3 errors ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:11:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"使用指南 输入变量 输入变量将数据提供给代码。例如copy(src,dest)方法src是输入参数 输出变量 输出变量接收在其他地方使用的数据。如copy(src,dest)方法dest是输出参数 当然有些变量既是输入也是输出,可以参考以下几点使用通配符: 输入变量使用上界通配符定义(使用extends关键字) 输出变量使用下界通配符定义(使用super关键字) 可以使用Object类中方法访问输入变量时,使用无界通配符 代码需要访问既是输入又是输出的变量时,不要使用通配符 这些指南不适用于方法返回类型。应避免使用通配符作为返回类型。 像List\u003c? extends … \u003e这样的列表可以认为它仅是只读的(并非严格意义上)。 class NaturalNumber { private int i; public NaturalNumber(int i) { this.i = i; } // ... } class EvenNumber extends NaturalNumber { public EvenNumber(int i) { super(i); } // ... } List\u003cEvenNumber\u003e le = new ArrayList\u003c\u003e(); List\u003c? extends NaturalNumber\u003e ln = le; ln.add(new NaturalNumber(35)); // compile-time error 因为List\u003cEvenNumber\u003e是List\u003c? extends NaturalNumber\u003e的子类型,所以可以把le赋值给ln。但是你不能使用ln添加自然数,因为它实际上是偶数列表,下列操作是可以的(从以下几点可以看出List\u003c? extends NaturalNumber\u003e并不是严格语意上的只读): 添加null 调用clear 获取迭代器并调用remove 捕获通配符并写入列表中读取的元素 类型擦除 Java语言引入泛型以在编译期提供严格类型检查。Java编译器应用类型擦除来实现泛型： 如果类型参数是无界的，使用它们的边界或Object代替所有的类型参数 如有必要执行类型转换 生成桥接方法以保证在泛型类型继承中的多态性 类型擦除确保没有为参数化类型创建新类,因此,泛型没有运行时开销。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:12:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型类中的擦除 Java编译器擦除所有类型参数,如果类型参数是有界的,则使用首个边界代替;如果类型参数是无界的,则使用Object代替。 考虑下面的泛型类： public class Node\u003cT\u003e { private T data; private Node\u003cT\u003e next; public Node(T data, Node\u003cT\u003e next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } 因为类型参数是无界的,Java编译器使用Object代替: public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } 当泛型类Node使用有界类型参数时,Java编译器使用首个边界类代替类型参数: public class Node\u003cT extends Comparable\u003cT\u003e\u003e { private T data; private Node\u003cT\u003e next; public Node(T data, Node\u003cT\u003e next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } //泛型擦除后 public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:13:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"泛型方法中的擦除 与泛型类中的擦除类似: // Counts the number of occurrences of elem in anArray. // public static \u003cT\u003e int count(T[] anArray, T elem) { int cnt = 0; for (T e : anArray) if (e.equals(elem)) ++cnt; return cnt; } //擦除后 public static int count(Object[] anArray, Object elem) { int cnt = 0; for (Object e : anArray) if (e.equals(elem)) ++cnt; return cnt; } class Shape { /* ... */ } class Circle extends Shape { /* ... */ } class Rectangle extends Shape { /* ... */ } public static \u003cT extends Shape\u003e void draw(T shape) { /* ... */ } //擦除后 public static void draw(Shape shape) { /* ... */ } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:14:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"类型擦除的影响和桥接方法 以下例子展示了编译器在类型擦除的过程中如何创建桥接方法。 public class Node\u003cT\u003e { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node\u003cInteger\u003e { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = mn.data; //类型擦出后 MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning // Note: This statement could instead be the following: // Node n = (Node)mn; // However, the compiler doesn't generate a cast because // it isn't required. n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. Integer x = (Integer)mn.data; 桥接方法 当编译一个继承于参数化类的类或接口,或实现一个参数化接口时,编译器会自动创建一个桥接方法。 类型擦除后，Node和MyNode类： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } 可以注意到类型擦除后,方法签名不匹配了,Node.setData(T)方法变成了Node.setData(Object)。也就是说MyNode.setData(Integer)没有重写Node.setData(Object)。 为了保证泛型擦出后的多态性，编译器生成了一个桥接方法： class MyNode extends Node { // Bridge method generated by the compiler // public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } 桥接方法MyNode.setData(object)委托给了原始方法MyNode.setData(Integer)。所以n.setData(“Hello”);语句调用的是 MyNode.setData(Object)方法，所以才会抛出ClassCastException（因为\"Hello\"不能转换成Integer）。 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:15:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"非具体类型（Non-Reifiable Types） 具体类型指在类型信息在运行时可知道类型,包括: 原始类型 非泛型类型 raw type 无界通配符调用 非具体类型指类型信息在编译器被擦除的类型:调用不是由无界通配符定义的泛型类型。其类型信息在运行时不完全可知,如List\u003cString\u003e和List\u003cNumber\u003e，JVM在运行时无法分辨这两者点区别。 在某些场景下非具体类型是不能使用的，如instanceof语句或作为数组元素。 堆污染 当一个参数化类型的变量指向一个不是这些参数化类型的对象时，就会发生堆污染。如果该程序执行某些操作会引起编译时的未受检警告，则会发生这种情况。当包含一个参数化类型的操作(如转换或方法调用)在编译时或运行时无法被验证时,就会生成未受检警告。例如，混用原始类型（raw type）和参数化类型时,或执行未受检转换时就会出现堆污染。 含非具体类型形参的可变参方法的漏洞 包含可变长入参的泛型方法可能造成堆污染： public class ArrayBuilder { public static \u003cT\u003e void addToList (List\u003cT\u003e listArg, T... elements) { for (T x : elements) { listArg.add(x); } } public static void faultyMethod(List\u003cString\u003e... l) { Object[] objectArray = l; // Valid但是可能产生堆污染 objectArray[0] = Arrays.asList(42); String s = l[0].get(0); // ClassCastException thrown here } } public class HeapPollutionExample { public static void main(String[] args) { List\u003cString\u003e stringListA = new ArrayList\u003cString\u003e(); List\u003cString\u003e stringListB = new ArrayList\u003cString\u003e(); ArrayBuilder.addToList(stringListA, \"Seven\", \"Eight\", \"Nine\"); ArrayBuilder.addToList(stringListB, \"Ten\", \"Eleven\", \"Twelve\"); List\u003cList\u003cString\u003e\u003e listOfStringLists = new ArrayList\u003cList\u003cString\u003e\u003e(); ArrayBuilder.addToList(listOfStringLists, stringListA, stringListB); ArrayBuilder.faultyMethod(Arrays.asList(\"Hello!\"), Arrays.asList(\"World!\")); } } //warning: [varargs] Possible heap pollution from parameterized vararg type T 当编译器进入一个可变长参数方法时，会将其转换成数组。但是Java语言不允许创建参数化类型的数组。Java编译器会将T…elements转换成Object[] elements，这可能产生堆污染。 阻止带不可变类型的可变长参数方法的警告 @SafeVarargs @SuppressWarnings({“unchecked”,“varargs”}):注意这无法抑制从方法调用处产生的警告 泛型约束 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:16:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能使用原始类型实例化泛型类型 class Pair\u003cK, V\u003e { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } // ... } Pair\u003cint, char\u003e p = new Pair\u003c\u003e(8, 'a'); // compile-time error ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:17:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建类型参数的实例 public static \u003cE\u003e void append(List\u003cE\u003e list) { E elem = new E(); // compile-time error list.add(elem); } 但是你可以通过反射创建类型参数的对象 public static \u003cE\u003e void append(List\u003cE\u003e list, Class\u003cE\u003e cls) throws Exception { E elem = cls.newInstance(); // OK list.add(elem); } //调用 List\u003cString\u003e ls = new ArrayList\u003c\u003e(); append(ls, String.class); ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:18:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能声明为静态属性 ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:19:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能转换或使用instanceof语句 public static \u003cE\u003e void rtti(List\u003cE\u003e list) { if (list instanceof ArrayList\u003cInteger\u003e) { // compile-time error // ... } } List\u003cInteger\u003e li = new ArrayList\u003c\u003e(); List\u003cNumber\u003e ln = (List\u003cNumber\u003e) li; // compile-time error 有时候转换是允许的： List\u003cString\u003e l1 = ...; ArrayList\u003cString\u003e l2 = (ArrayList\u003cString\u003e)l1; // OK 另外，无界通配符可以使用instanceof： public static void rtti(List\u003c?\u003e list) { if (list instanceof ArrayList\u003c?\u003e) { // OK; instanceof requires a reifiable type // ... } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:20:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建参数化类型的数组 List\u003cInteger\u003e[] arrayOfLists = new List\u003cInteger\u003e[2]; // compile-time error //如果不同的类型插入到同一个数组将会产生异常 Object[] strings = new String[2]; strings[0] = \"hi\"; // OK strings[1] = 100; // An ArrayStoreException is thrown. //所以类似的，不允许这样创建参数化类型的数组 Object[] stringLists = new List\u003cString\u003e[2]; // compiler error, but pretend it's allowed stringLists[0] = new ArrayList\u003cString\u003e(); // OK stringLists[1] = new ArrayList\u003cInteger\u003e(); // An ArrayStoreException should be thrown, // but the runtime can't detect it. ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:21:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"不能创建，捕获或抛出参数化类型的对象 泛型类不能直接或间接地继承Throwable类。 // Extends Throwable indirectly class MathException\u003cT\u003e extends Exception { /* ... */ } // compile-time error // Extends Throwable directly class QueueFullException\u003cT\u003e extends Throwable { /* ... */ // compile-time error public static \u003cT extends Exception, J\u003e void execute(List\u003cJ\u003e jobs) { try { for (J job : jobs) // ... } catch (T e) { // compile-time error // ... } } 但是可以在throws语句中使用类型参数： class Parser\u003cT extends Exception\u003e { public void parse(File file) throws T { // OK // ... } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:22:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["Java编程"],"content":"参数在类型擦除后一眼的方法不能重载 public class Example { //'print(Set\u003cString\u003e)' clashes with 'print(Set\u003cInteger\u003e)'; both methods have same erasure public void print(Set\u003cString\u003e strSet) { } public void print(Set\u003cInteger\u003e intSet) { } } ","date":"2025-04-14","objectID":"/java%E6%B3%9B%E5%9E%8B/:23:0","tags":["Java基础"],"title":"Java中的泛型","uri":"/java%E6%B3%9B%E5%9E%8B/"},{"categories":["数据结构"],"content":"多路查找树(m-way search tree) 多路查找树是一种用来高效搜索或检索数据的数据结构。m表示最大子节点数。如二叉树也叫2-way查找树。多路查找树主要用来优化搜索(因为树高度更小、每个节点存储的key更多)，最优时间复杂度为O($\\log_mn$)。 最大子节点数为m 节点最大元素数为m-1 最大元素数$m^(h+1)-1$,h为树的高度,这里高度定义为树中任一节点到根节点的路径最大值 最优时间复杂度为O($\\log_mn$),这可以通过使用不同的平衡策略可以达到,如B树：除根节点外的其他非叶子节点最少有m/2个子节点;最差时间复杂度0(n) 元素升序排列:左子树值小于根节点,右子树值大于根节点。具体来说：前i个子节点的值均小于第i个key的值;后m-i个子节点的值均大于第i个key的值 以下面的5路查找树为例: public class MultiwaySearchTree { public static class TreeNode { public int val; //左子节点 public TreeNode left; //右子节点 public TreeNode right; //下一个节点 public TreeNode next; public TreeNode(int val, TreeNode right, TreeNode left, TreeNode next) { this.val = val; this.right = right; this.left = left; this.next = next; } public TreeNode(int val) { this.val = val; } @Override public String toString() { return \"TreeNode{\" + \"val=\" + val + \", left=\" + left + \", right=\" + right + \", next=\" + next + '}'; } } public static TreeNode search(TreeNode root, int val) { if (root == null) return null; if (root.val == val) return root; //如果查找值小于当前节点值,以当前节点的左子节点为根继续查找 if (root.val \u003e val) { if (root.left == null) return null; return search(root.left, val); } //如果查找值大于当前节点值且当前节点没有后续节点,以当前节点的右子节点为根继续查找 if (root.next == null) { if (root.right == null) return null; return search(root.right, val); } if (root.next.val == val) return root.next; //如果查找值介于当前节点值和当前节点的下一节点值之间,则以当前节点的右子节点为根继续查找 if (root.next.val \u003c val) return search(root.next, val); //如果查找值大于当前节点和当前节点的下一节点值,则以当前节点的下一节点为根继续查找 return search(root.right, val); } public static void main(String[] args) { TreeNode root = new TreeNode(18); root.next = new TreeNode(54); root.next.next = new TreeNode(86); root.next.next.next = new TreeNode(400); root.next.next.next.right = new TreeNode(450); root.next.next.next.right.next = new TreeNode(470); root.left = new TreeNode(5); root.left.next = new TreeNode(10); root.left.right = new TreeNode(7); root.left.right.next = new TreeNode(9); root.right = new TreeNode(25); root.right.next = new TreeNode(35); root.right.next.next = new TreeNode(40); root.right.next.next.right = new TreeNode(45); root.right.left = new TreeNode(19); root.right.left.next = new TreeNode(20); root.right.left.next.next = new TreeNode(21); root.right.left.next.next.next = new TreeNode(22); System.out.println(search(root, 40)); } } 可能以上代码例子还不太直观，不能体现一个节点可以有多个key，下面再看一个例子。 相应的数据结构可以表示为 public class Node { int count;//子节点数 int[] value = new int[3]; Node[] child = new Node[4]; } B树（B-tree） B树是一种特殊的多路查找树(B树也是平衡版的二叉树)：B树是自平衡的多路查找树数据结构，能以对数时间搜索，访问，插入和删除元素。B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快访问速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。 B树相较于多路查找树有以下两个特性： 自平衡：每个叶子节点深度相同 除了根节点的节点的元素在[ceil(m/2),m-1]之间(也有说是[m/2-1,m-1])，根节点的元素个数在[1,m-1]之间 如果根节点不是叶子节点，那么它至少有两个子节点（2-3树是最简单的B树）；内部节点最少有ceil(m/2)个子节点 插入、删除和搜索操作时间复杂度为O($logn$)，n为树中存储key的个数。另外其空间复杂度为O(n)。 辅助存储设备通常容量大但读写慢，因此需要像B树这样的数据结构来减少磁盘访问。其他的数据结构像二叉查找树，avl树，红黑树等的每个节点仅存储一个值，如果需要存储大量值，树都高度将会变大导致访问时间增加。 B树能在一个节点存储多个值并且有多个子节点，这减少了树都高度，从而让磁盘访问更快。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:0:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 插入过程如下: 1.如果树为空,构建一个根节点并插入值 2.寻找合适的节点插入(符合B树特性的节点) 3.如果节点没有多余的位置，按以下步骤执行： 3.1按升序排列插入元素 3.2当前节点已超过最大key数量限制,按中间值分裂 3.3向上弹出中间值,中间值左边的值作为左子节点,中间值右边的值作为右子节点 3.4如果上层节点的值未满,则按升序插入到上层节点 3.5如果上层节点的值已满,重复步骤3 例:构建一个B树，M=3，值为12,23,6,8,15,19,45,1,4,7,5。 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:1:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在叶子节点 1.1叶子节点key数量大于最小key数量 1.1.1直接删除目标key 1.2叶子节点只有最小数量key 1.2.1从当前左兄弟节点借一个最大key(仅当左兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.2 1.2.2从当前右兄弟节点借一个最小key(仅当右兄弟节点key数量大于最小值),将该key移到父节点,将父节点key移到目标节点以替换要删除的目标key。如无法执行上述动作，执行1.2.3 1.2.3与左兄弟节点和父节点key合并或者与右兄弟节点和父节点key合并,然后删除目标key 以M=5的一颗B树来演示上述步骤： ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"目标key在内部节点 2.1有序前驱(左子树最大元素) 2.1.1找到左子树中最大key代替要删除的目标key。左子树元素数量要大于节点最小元素数量 2.2有序后继(右子树最小元素) 2.2.1找到右子树中最小key代替要删除的目标key。右子树元素数量要大于节点最小元素数量 2.3上述都不满足,合并左右子节点和目标key,然后删除目标key ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 无法从左右子树取值时，合并导致高度减少。 以下Java代码来自java-algorithms-implementation仓库 package datastructure; import java.util.*; /** * @author cheysen * @date 2025/4/3 12:36 * @description B 树是一种树数据结构，它使数据保持排序并允许对数时间的搜索、顺序访问、插入和删除。 * B 树是二叉搜索树的泛化，因为一个节点可以有两个以上的子节点。与自平衡二叉搜索树不同，B 树针对读取和写入大型数据块的系统进行了优化。它通常用于数据库和文件系统。 **/ @SuppressWarnings(\"unchecked\") public class BTree\u003cT extends Comparable\u003cT\u003e\u003e implements Tree\u003cT\u003e { //2-3树是最简单的B树:最大key数量2,最大子节点数3,最小key数量2 private int minKeySize = 1; private int minChildrenSize = minKeySize + 1; private int maxKeySize = 2 * minKeySize; private int maxChildrenSize = maxKeySize + 1; private Node\u003cT\u003e root = null; private int size = 0; //默认2-3树 public BTree() { } //order:非根节点最少key数量 public BTree(int order) { this.minKeySize = order; this.minChildrenSize = minKeySize + 1; this.maxKeySize = 2 * minKeySize; this.maxChildrenSize = maxKeySize + 1; } public BTree\u003cT\u003e appendAdd(T value) throws Exception { boolean added = add(value); if (added) { return this; } else { throw new Exception(\"add \" + value + \" error\"); } } @Override public boolean add(T value) { if (root == null) { root = new Node\u003cT\u003e(null, maxKeySize, maxChildrenSize); root.addKey(value); } else { Node\u003cT\u003e node = root; while (node != null) { //没有子节点就在当前节点插入 if (node.numberOfChildren() == 0) { node.addKey(value); if (node.numberOfKeys() \u003c= maxKeySize) { break; } //key数量已满，需要分裂 split(node); break; } //否则，按有序的规则查找该插入的节点 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c= 0) { node = node.getChild(0); continue; } int numberOfKeys = node.numberOfKeys(); int last = numberOfKeys - 1; T greater = node.getKey(last); if (value.compareTo(greater) \u003e 0) { node = node.getChild(numberOfKeys); continue; } for (int i = 1; i \u003c node.numberOfKeys(); i++) { T prev = node.getKey(i - 1); T next = node.getKey(i); if (value.compareTo(prev) \u003e 0 \u0026\u0026 value.compareTo(next) \u003c= 0) { node = node.getChild(i); break; } } } } size++; return true; } @Override public T remove(T value) { T removed = null; Node\u003cT\u003e node = this.getNode(value); removed = remove(value, node); return removed; } @Override public boolean contains(T value) { Node\u003cT\u003e node = getNode(value); return node != null; } @Override public void clear() { root = null; size = 0; } @Override public int size() { return size; } @Override public boolean validate() { if (root == null) { return true; } return validateNode(root); } @Override public Collection\u003cT\u003e toCollection() { return new JavaCompatibleBTree\u003c\u003e(this); } @Override public String toString() { return TreePrinter.getString(this); } /** * 获取目标值所在节点 * @param value 要查找的值 * @return 目标值所在节点 */ private Node\u003cT\u003e getNode(T value) { Node\u003cT\u003e node = root; while (node != null) { //尝试是否比节点最小值小 T lesser = node.getKey(0); if (value.compareTo(lesser) \u003c 0) { if (node.numberOfChildren() \u003e 0) { node = node.getChild(0); } else { node = null; } continue; } //尝试是否比节点最大值大 int numberOfKeys = node.numberOfKeys(); int lastIndex = numberOfKeys - 1; T greater = node.getKey(lastIndex); if (value.compareTo(greater) \u003e 0) { if (node.numberOfChildren() \u003e numberOfKeys) { node = node.getChild(numberOfKeys); } else { node = null; } continue; } //不满足极大极小情况,在中间值中比较 for (int i = 0; i \u003c numberOfKeys; i++) { T currentValue = node.getKey(i); if (currentValue.compareTo(value) == 0) { return node; } int next = i + 1; if (next \u003c= lastIndex) { T nextValue = node.getKey(next); //目标值介于第i与第i+1个key之间时,在第i+1个子节点(如果有)中继续查找 if (value.compareTo(currentValue) \u003e 0 \u0026\u0026 value.compareTo(nextValue) \u003c 0) { if (next \u003c node.numberOfChildren()) { node = node.getChild(next); break; } return null; } } } } return null; } /** * 从节点中删除值 * @param value 要删除的值 * @param node 要删除的值所在节点 * @return true-删除成功 */ private T remove(T value, Node\u003cT\u003e node) { if (node == null) { return null; } T removed = null; int index = node.indexOf(value); removed = node.removeKey(index); //叶子节点元素的删除:1.直接删除 2.兄弟节点借值 3.合并兄弟节点(之一)与父节点key if (node.numberOfChildren() == 0) { if (node.parent != null \u0026\u0026 node.numberOfKeys() \u003c minKeySize) { this.combined(node); } else if (node.parent == n","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:2:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"插入 B+树都插入根B树类似,需要注意以下两点 内部节点分裂时,key不重复 子节点分裂时,分裂的中间值在右子节点重复 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:3:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"删除 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:0","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key仅在叶子节点 节点key数量大于最小key数量 直接删除 节点只有最小key数量 删除该key，从直接兄弟节点借一个key，将兄弟节点的中间key移到父节点 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:1","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"key存在于内部节点和叶子节点 key数量大于最小key数量 直接删除内部节点和叶子节点的key，用有序后继填充内部节点删除的位置 只有最小key数量且key所在位置相邻 删除该key,从直接兄弟节点借一个值，填充内部节点删除的位置 只有最小key数量且key所在位置不相邻 删除该key,合并兄弟节点，用有序后续填充内部节点删除的位置 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:2","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["数据结构"],"content":"高度减少 ","date":"2025-04-09","objectID":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/:4:3","tags":["树"],"title":"B树与B+树","uri":"/b%E6%A0%91%E4%B8%8Eb-%E6%A0%91/"},{"categories":["Java编程"],"content":"1. 枚举类型的介绍 枚举类型是一种特殊的数据类型，它使得变量成为一组预定义常量。所以在需要表示一组固定常量时应尽量使用枚举类型。通过关键字enum来定义枚举类，它和普通类一样可以有构造器、成员变量、方法。 1.1 枚举类的特性 所有的枚举类都隐式的继承java.lang.Enum，Java不允许多继承，所以枚举类不能再继承其他任何类，但可以实现接口 枚举类被隐式地声明为final，所以也不能被其他任何类继承 枚举类型的构造函数修饰符必须是private。定义枚举常量时会自动调用，不能自己调用枚举的构造函数 枚举类的实例必须在第一行列出，并且枚举值默认被public static final修饰 编译时编译器会自动帮我们添加两个静态方法values()和valueOf() 1.2 枚举类的原理 下面我们定义了一个枚举类并让它实现Info接口，这样可以让枚举值提供不同的实现，当然也可以在枚举类里面定义一个抽象方法，这样枚举值也必须实现此抽象方法才可，效果都一样。 public enum Season implements Info{ SPRING(\"spring\",\"春暖花开\"){ public void show(){ System.out.println(\"春天在哪里\"); } }, SUMMER(\"summer\",\"夏日炎炎\"){ public void show(){ System.out.println(\"生如夏花\"); } }, AUTUMN(\"autumn\",\"秋高气爽\"){ public void show(){ System.out.println(\"秋\"); } }, WINTER(\"winter\",\"白雪茫茫\"){ public void show(){ System.out.println(\"冷\"); } }; private final String seasonName; private final String seasonDesc; Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } } 可以看到该枚举类编译后的class文件，其中还包括了四个枚举值对应的class文件，而且其后还带有序号。在枚举实例创建时会给每个枚举值指定一个整形常量值（序号），若没有显示指定，则 整形常量值从0开始递增。这其实是与父类Enum有关，后面会介绍。 下面是利用javap工具查看Season.java经过编译后的字节码（请忽略乱码–.–）: \"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\javap.exe\" -c pre.chl.enums.Season Compiled from \"Season.java\" public abstract class pre.chl.enums.Season extends java.lang.Enum\u003cpre.chl.enums.Season\u003e implements pre.chl.enums.Info { public static final pre.chl.enums.Season SPRING; public static final pre.chl.enums.Season SUMMER; public static final pre.chl.enums.Season AUTUMN; public static final pre.chl.enums.Season WINTER; public static pre.chl.enums.Season[] values(); Code: 0: getstatic #2 // Field $VALUES:[Lpre/chl/enums/Season; 3: invokevirtual #3 // Method \"[Lpre/chl/enums/Season;\".clone:()Ljava/lang/Object; 6: checkcast #4 // class \"[Lpre/chl/enums/Season;\" 9: areturn public static pre.chl.enums.Season valueOf(java.lang.String); Code: 0: ldc #5 // class pre/chl/enums/Season 2: aload_0 3: invokestatic #6 // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; 6: checkcast #5 // class pre/chl/enums/Season 9: areturn public java.lang.String getSeasonName(); Code: 0: aload_0 1: getfield #8 // Field seasonName:Ljava/lang/String; 4: areturn public java.lang.String getSeasonDesc(); Code: 0: aload_0 1: getfield #9 // Field seasonDesc:Ljava/lang/String; 4: areturn public java.lang.String toString(); Code: 0: new #10 // class java/lang/StringBuilder 3: dup 4: invokespecial #11 // Method java/lang/StringBuilder.\"\u003cinit\u003e\":()V 7: ldc #12 // String Season{seasonName=' 9: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 12: aload_0 13: getfield #8 // Field seasonName:Ljava/lang/String; 16: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: bipush 39 21: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 24: ldc #15 // String , seasonDesc=' 26: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: aload_0 30: getfield #9 // Field seasonDesc:Ljava/lang/String; 33: invokevirtual #13 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 36: bipush 39 38: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 41: bipush 125 43: invokevirtual #14 // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder; 46: invokevirtual #16 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 49: areturn pre.chl.enums.Season(java.lang.String, int, java.lang.String, java.lang.String, pre.chl.enums.Season$1); Code: 0: aload_0 1: aload_1 2: iload_2 3: aload_3 4: aload 4 6: invokespecial #1 // Method \"\u003cinit\u003e","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:1","tags":["Java基础"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["Java编程"],"content":"2. 枚举类的使用 2.1 定义 public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } 枚举值之间使用\",“分隔，如果后面没有属性或方法，最后加不加”;“都行。但如果有就一定要加”;\" public enum PurOrderSplitEnum { NORELEASEERPBILLCOUNT(\"1\", \"待发布\"), RELEASEERPBILLCOUNT(\"2\", \"待买方确认\"), PURCONFIRMINGCOUNT(\"3\", \"买方变更中\"); private String code; private String name; public static Map\u003cString, String\u003e code2name = new HashMap(); public static Map\u003cString, String\u003e code2Muname = new HashMap(); private PurOrderSplitEnum(String code, String name) { this.code = code; this.name = name; } public String getCode() { return this.code; } public String getName() { return this.name; } static { code2name.put(NORELEASEERPBILLCOUNT.getCode(), NORELEASEERPBILLCOUNT.getName()); code2name.put(RELEASEERPBILLCOUNT.getCode(), RELEASEERPBILLCOUNT.getName()); code2name.put(PURCONFIRMINGCOUNT.getCode(), PURCONFIRMINGCOUNT.getName()); code2Muname.put(NORELEASEERPBILLCOUNT.getCode(), \"NORELEASEERPBILLCOUNT\"); code2Muname.put(RELEASEERPBILLCOUNT.getCode(), \"RELEASEERPBILLCOUNT\"); code2Muname.put(PURCONFIRMINGCOUNT.getCode(), \"PURCONFIRMINGCOUNT\"); } } 2.2 结合Switch 在switch中使用枚举，可以让我们的代码可读性更好 public class EnumTest { Day day; public EnumTest(Day day) { this.day = day; } public void tellItLikeItIs() { switch (day) { case MONDAY: System.out.println(\"周一还行吧\"); break; case FRIDAY: System.out.println(\"周五很nice\"); break; case SATURDAY: case SUNDAY: System.out.println(\"周末超级棒\"); break; default: System.out.println(\"额....\"); break; } } public static void main(String[] args) { EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); EnumTest fifthDay = new EnumTest(Day.FRIDAY); fifthDay.tellItLikeItIs(); EnumTest sixthDay = new EnumTest(Day.SATURDAY); sixthDay.tellItLikeItIs(); EnumTest seventhDay = new EnumTest(Day.SUNDAY); seventhDay.tellItLikeItIs(); } //输出结果 /* 周一还行吧 额.... 周五很nice 周末超级棒 周末超级棒 */ 2.3 valueOf方法 把字符串转成对应类型的枚举值，如： String str = \"SPRING\"; Season season2 = Season.valueOf(str); //Season season2 = Season.valueOf(Season.class,str);跟上面是等价的 System.out.println(season2 == season1);//true 2.4 values()和其他方法 values()方法可以返回所有定义的枚举值，name()方法返回的是枚举的名称，不是枚举值里面的属性名称，这里需要注意一下。 Season season1 = Season.SPRING; for(Season season:Season.values()){ System.out.println(season); } season1.show(); System.out.println(season1.name()); System.out.println(\"SPIRNG的序号:\" + season1.ordinal()); //输出结果 /* Season{seasonName='spring', seasonDesc='春暖花开'} Season{seasonName='summer', seasonDesc='夏日炎炎'} Season{seasonName='autumn', seasonDesc='秋高气爽'} Season{seasonName='winter', seasonDesc='白雪茫茫'} 春天在哪里 SPRING 0 */ 2.5 使用接口组织枚举 在接口中定义枚举类，可以将数据分组。 public interface Animal { enum Dog implements Animal { HUSKY,GOLDEN_RETRIEVER,ALASKAN_MALAMUTE } enum Cat implements Animal { PERSIAN,RAGDOLL,BIRMAN } } // Animal dog = Animal.Dog.ALASKAN_MALAMUTE; // Animal cat = Animal.Cat.BIRMAN; 2.6 EnumSet和EnumMap Set类型是枚举集或Map的key是枚举值时，使用这两者将会更加高效。这里只摘取Java API文档的部分说明，详细的方法大家可以自己查找文档。 EnumMap 用于枚举类型键的专用Map实现。 枚举映射中的所有键必须来自创建映射时显式或隐式指定的单个枚举类型。 枚举映射在内部表示为数组。 这种表现非常紧凑和高效。 枚举映射按其键的自然顺序（枚举常量的声明顺序）维护。 这反映在集合视图（keySet（），entrySet（）和values（））返回的迭代器中。 集合视图返回的迭代器非常一致：它们永远不会抛出ConcurrentModificationException，它们可能会也可能不会显示迭代进行过程中对映射所做的任何修改的影响。 Key不允许为null。 尝试插入null将抛出NullPointerException。 但是，尝试测试是否存在空键或删除空键将正常运行。 value允许为null。 与大多数集合实现一样，EnumMap不同步。 如果多个线程同时访问枚举映射，并且至少有一个线程修改了映射，则应该在外部进行同步。 这通常通过在自然封装枚举映射的某个对象上同步来完成。 如果不存在此类对象，则应使用Collections.synchronizedMap（java.util.Map \u003cK，V\u003e）方法“包装”映射。 这最好在创建时完成，以防止意外的不同步访问： Map \u003cEnumKey，V\u003e m= Collections.synchronizedMap（new EnumMap \u003cEnumKey，V\u003e（...））; 说明：所有基本操作都在恒定时间内执行。 它们很可能（虽然不能保证）比它们对应的HashMap更快。 EnumSet 用于枚举类型的专用Set实现。 枚举集中的所有元素必须来自单个枚举类型，该类型在创建集时显式或隐式指定。 枚举集在内部表示为位向量。 这种表现非常紧凑和高效。 这个类的空间和时间性能应该足够好，以允许它作为传统的基于int的“位标志”的高性能、类型安全的替代品。 如果它们的参数也是枚举集，即使批量操作（例如containsAll和retainAll）也应该非常快速地运行。 迭代器方法返回的迭代器以其自然顺序（枚举常量声明的顺序）遍历元素。 返回的迭代器是弱一致的：它永远不会抛出ConcurrentModificationException，它可能会也可能不会显示迭代进行过程中对集合所做的任何修改的影响。 不允许使用空元素。 尝试插入null元素将抛出NullPointerException","date":"2019-07-22","objectID":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/:0:2","tags":["Java基础"],"title":"Java枚举类型介绍和使用","uri":"/java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"categories":["网络安全"],"content":"1. XSS简介 跨站脚本(Cross Site Script)为了避免与CSS混淆,简称XSS。XSS是指攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，在输入框添加一些代码，嵌入到web页面中，使别的用户访问会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。XSS又分为反射型、存储型和DOM-Based型。 XSS的危害包括： 盗取用户Cookie DDOS客户端浏览器 盗窃企业重要的具有商业价值的资料 爆发web2.0蠕虫 强制发送电子邮件 网站挂马，钓鱼攻击 劫持用户web行为甚至渗透内网 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:1:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"2. 原理 （1）反射型 服务端返回脚本，客户端执行。如URL注入非法脚本，然后诱导用户点击该链接，但是一般浏览器都会有基本防御措施，自带拦截过滤；服务端返回的富文本中包含非法脚本，被直接展示。 （2）存储型 后台被动存储了非法脚本，并且前端直接展示。如发帖或留言中发出包含恶意代码的内容,其他用户访问该内容后,满足特定条件即触发,这种需要后台不过滤信息,并且前端展示时也不过滤信息。 （3）DOM-Based型 基于DOM或本地的XSS攻击。如wifi流量劫持、DNS劫持并直接返回钓鱼页面。本质是需要更改DOM，再排除自己攻击自己。某些反射型的攻击也能造成这个后果-通过url控制DOM。在传统的XSS中，恶意JavaScript脚本在页面加载时执行，而在基于DOM的XSS中，恶意JavaScript脚本在页面加载后的某个时刻执行。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:2:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"3.自动化XSS Browser Exploitation Framework(BeEF),是目前强大的浏览器开源渗透测试框架,通过XSS漏洞配合JS脚本和Metasploit进行渗透。它是基于Ruby编写，支持图形化界面，操作简单。 Kali linux已经自带BeEF,另外我使用一个开源的靶机OWASP Broken Web Apps来练习。 在靶机的低安全级别下执行一个存储型的XSS： 然后使用win10的Google浏览器访问靶机的相应被注入脚本的页面后，BeEF中的记录： 之后就可以使用beef控制用户的浏览器进行多种操作（比如钓鱼），但是这里并没有win10的记录，原因是chrome对该XSS进行了过滤。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:3:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["网络安全"],"content":"4. 如何预防 （1）编码，转义用户输入，编码可在前端和后端中进行。常见的如下图的HTML转义 但是编码并不适用所有情况，比如当用户需要提供一个URL或者编写用户配置文件时，对输入编码是不友好的，不应对用户的自定义配置做限制，所以需要使用验证。 （2）验证，过滤用户输入。有两种实现方式 分类策略，使用白名单或黑名单分类 验证结果，拒绝或删除不合法的输入 （3）CSP内容安全策略（CSP） CSP用于约束浏览器只能使用从可信来源下载的资源。资源是页面引用的脚本，样式表，图像或其他类型的文件。这样即使攻击者成功将恶意内容注入到网站，CSP也可以防止它被执行。 CSP可用于执行以下规则： 没有不受信任的来源。外部资源只能从一组明确定义的可信来源加载。 没有内联资源。不会评估内联JavaScript和CSS。 无法使用JavaScript eval函数。 Content‑Security‑Policy: script‑src 'self' scripts.example.com; media‑src 'none'; img‑src *; default‑src 'self' http://*.example.com 以上CSP表明脚本只能从提供页面的主机和scripts.example.com下载。 无法从任何地方下载音频和视频文件。可以从任何主机下载图像文件。 所有其他资源只能从提供该页面的主机和example.com的任何子域下载。 (4) 其他方法 Cookie设置http-only。http-only标志可以防止cookie被“读取”，但不能防止被“写”,已证明有些浏览器的http-only标记可以被JavaScript写入覆盖，而这种覆盖可能被攻击者利用发动session fixation攻击。 WAF,大多数使用规则匹配,也能被绕过。 X-XSS-Protection也有助于在一些浏览器中防止某些XSS，但在某些情况下可以被绕过。 ","date":"2019-05-22","objectID":"/%E6%B5%85%E8%B0%88xss/:4:0","tags":["XSS"],"title":"浅谈XSS","uri":"/%E6%B5%85%E8%B0%88xss/"},{"categories":["Java编程"],"content":"JMM(Java Memory Model),Java内存模型,它是一种Java虚拟机需要遵守的规范，定义了线程间如何在内存中正确地交互。JDK5以后的JMM规范在JSR-133中详细列出。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:0:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1. 内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.1 为什么需要内存模型 多线程编程的困难在于很难对程序进行调式，如果控制不好，就会产生意料之外的结果。对于传统的单核CPU来说，由于是并发执行，即同一时刻只有一个线程在执行，所以一般不会出现数据的访问冲突。这也不是绝对的，单核多线程场景下，如果允许抢占式调度，仍存在线程安全问题。当前的处理器架构大多是多核+多级缓存+主存的模式，这样在多线程场景下就存在数据竞争从而造成缓存不一致的问题。另外CPU可能会对程序进行优化，进行指令重排序，只要重排后程序的语义没有发生变化，指令重排就是有可能发生的（编译器和JVM也存在指令重排），但这有时会让多线程执行的结果出乎意料。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:1","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.2 什么是内存模型 对处理器来说，内存模型定义了充分必要条件，以知道其他处理器对内存的写入对当前处理器可见，而当前处理器的写入对其他处理器可见。一些处理器使用强内存模型，即所有处理器在任何给定的内存位置上始终能看到完全相同的值,但这也不是绝对的,某些时候也需要使用特殊指令(称为内存屏障)来完成。其他处理器使用弱内存模型，需要内存屏障来刷新或使本地处理器缓存失效，以便查看其他处理器的写操作或使此处理器的写操作对其他处理器可见。这些内存屏障通常在lock和unlock时执行；对于使用高级语言的程序员来说，它们是不可见的。处理器的设计趋势是鼓励使用弱内存模型,因为它们的规范具有更强的可伸缩性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:2","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"1.3 其他语言有内存模型吗 大多数其他编程语言（如C和C ++）的设计并未直接支持多线程。 这些语言针对编译器和体系结构中发生的各种重排序提供的保护很大程度上取决于所使用的线程库（例如pthread），所使用的编译器以及运行代码的平台所提供的保证。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:1:3","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.Java内存模型 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.1 简介 Java内存模型是建立在内存模型之上的，它回答了当读取一个确定的字段时什么样的值是可见的。它将一个Java程序分解成若干动作（actions）并且为这些动作分配一个顺序。如果分配的这些顺序中能在对一个字段的写操作(write actions)和读操作(read actions)间形成一个叫happens-before的关系,那么Java内存模型保证了读操作将返回一个正确的值。 JMM规定所有实例域、静态域和数组元素存储在JVM内存模型的的堆中，堆内存在线程间是共享的。局部变量和异常处理器参数不会共享，他们不存在内存可见性问题。每个线程创建时JVM都会为其创建一个工作内存(栈空间),工作内存是每个线程的私有数据区域,线程对变量的操作必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作内存空间,然后对变量进行操作,操作完成后再将变量写回主内存`,不能直接操作主内存中的变量,各个线程中的工作内存中存储着主内存中的变量副本拷贝,因此线程间的通信必须通过主内存来完成。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:1","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.2 代码优化问题 上面一段代码,模拟了两个线程。期望可能是thread1执行一次count++,thread2修改flag的值,然后thread1退出循环。但是在未做同步控制的情况下多线程的执行情况是无法预料的。还存在一个很重要的问题，那就是编译器优化（这里编译器可以是Java编译器如JIT，JVM，CPU）。 对于thread1，没有对flag的写操作，所以编译器认为flag的值总是true，就将flag直接改为true来提高程序运行速度，这种优化是被允许的，因为对于它本身而言没有改变程序语义。 对于thread2，没有要求对flag的值要刷回主存，编译器就可能优化为忽略对flag的写指令，因为不刷回主存的值改变只有线程自己可见。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:2","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.3 指令重排序问题 对上图中三条指令，我们期望是顺序执行，但某些编译器为了提高速度，很可能对指令重排序变成下面一种执行顺序。 再来看看下面的例子 处理器A 处理器B a = 1; // 写操作A1 b =2; //写操作B1 x = b; //读操作A2 y = a; //读操作B2 初始状态 a = b = 0 结果 x = y = 0 之所以会出现以上结果,是因为处理器对写读指令进行了重排序,如将顺序A1 -\u003e A2重排成A2 -\u003e A1。对写读的重排序在x86架构下是被允许的。下图是不同架构下支持的重排序类型，这解释了为什么相同的程序在不同的架构系统下会产生不同的结果，因为编译器可能对你的代码进行了不同的重排序。 另外重排序需要考虑到数据之间的依赖性，比如下面3条指令,3是不会排到指令1之前的,因为指令3依赖于指令1的数据x。 int x = 1; //1 int y = 2; //2 y = x * x; //3 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:3","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.4 可见性问题 观察以上代码，写线程在自己的工作内存中改变了x的值却并未来得及刷回主内存,这样读线程读取到的值仍然是旧值,读线程此时对写线程的操作不可见。Java为此提供了volatile关键字解决方案：只要用volatile修饰变量x,对x进行原子操作后,x的值将立马刷回主内存,这样保证了读线程对写线程的可见性。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:4","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.5 原子性问题 Java中long型占8字节,也就是64位,如果在64位操作系统中执行以上代码不存在原子性问题,对foo的写操作一步完成,但是在32位操作系统中这种写操作就失去了原子性。32位操作系统中对foo的写操作分两步进行-分别对高32位和低32位进行写操作。在这种情况下就可能产生如下结果 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:5","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.6 Happens-before规则 Happens-before表示动作上的偏序关系，官方文档对于该规则的定义如下 大致翻译一下就是: 两个动作可以由happends-before关系排序,如果一个动作happens-before另一个动作,那么第一个动作的执行结果对后一个动作可见。两个操作之间存在happens-before关系，并不意味着必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。例如，在线程构造的对象的每个字段中写入默认值不需要在该线程的开始之前发生，只要没有读取操作就会观察到该事实。另外，当两个动作存在于不同的线程中时，也存在这种关系，此种情况下两者之间会存在一个消息传递机制。 happens-before的8条规则如下： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:6","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"2.7 实现 字段域 方法域 final synchronized(method/block) volatile java.util.concurrent.* volatile public class VolatileFieldsVisivility{ int a = 0; volatile int x = 0; public void writeThread(){ a = 1; //1 x = 1; //2 } public void readThread(){ int r2 = x; //3 int d1 = a; //4 } } 假设写线程执行完后,问读线程读变量a的值是1还是0还是不确定?答案是确定的1，即使变量a未用volatile修饰。由上面给出的happens-before规则可推得：1 happens-before 2, 2 happens-before 3 , 3 happens-before 4 –\u003e 1 happens-before 4(传递性),即读线程读a的时候一定能看到写线程的执行结果，简短来说就是当一个线程对volatile修饰的变量写入，并且读取时也是此变量时在他之前的所有写操作被保证对其他线程是可见的。值得注意的是,写读操作必须是原子性的,如果被volatile修饰的是long或者double,那么这个64位的变量不能被拆分存储。也就是说volatile保证了可见性和有序性,但不保证原子性。 由于篇幅过长,其他方式的实现我将在其他文章中单独抽出来分析。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:2:7","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"categories":["Java编程"],"content":"3. 总结 Java内存模型就是Java语言在内存模型上的实现，它是为了保证多线程场景下的原子性、可见性和有序性提出的规范。Java语言提供了volatile、synchronized、final关键字和java.util.concurrent.*并发编程包来实现这些规范,这些提供给程序员的原语和包屏蔽了和底层交互的细节,让程序员可以更方便快捷地编程。 ","date":"2019-05-08","objectID":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/:3:0","tags":["Java内存模型"],"title":"简单理解Java内存模型","uri":"/%E7%90%86%E8%A7%A3java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"}]