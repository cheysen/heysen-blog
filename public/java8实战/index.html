<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Java8实战 - H2oLo</title><meta name="Description" content="cheysen的个人博客"><meta property="og:title" content="Java8实战" />
<meta property="og:description" content="1.基础知识 1.1 流处理 流是一系列数据项，一次只生成一项。可以想象成汽车组装流水线，尽管流水线实际上是一个序列，但不同加工站的运行一般是并行的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://heysen.xyz/java8%E5%AE%9E%E6%88%98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-16T20:19:15+08:00" />
<meta property="article:modified_time" content="2025-04-16T20:19:15+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java8实战"/>
<meta name="twitter:description" content="1.基础知识 1.1 流处理 流是一系列数据项，一次只生成一项。可以想象成汽车组装流水线，尽管流水线实际上是一个序列，但不同加工站的运行一般是并行的。"/>
<meta name="application-name" content="H2oLo">
<meta name="apple-mobile-web-app-title" content="H2oLo"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://heysen.xyz/java8%E5%AE%9E%E6%88%98/" /><link rel="prev" href="https://heysen.xyz/java%E6%B3%9B%E5%9E%8B/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Java8实战",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/heysen.xyz\/java8%E5%AE%9E%E6%88%98\/"
        },"genre": "posts","keywords": "Java基础","wordcount":  11786 ,
        "url": "https:\/\/heysen.xyz\/java8%E5%AE%9E%E6%88%98\/","datePublished": "2025-04-16T20:19:15+08:00","dateModified": "2025-04-16T20:19:15+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": " "
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="H2oLo"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/hydrogen.png"
        data-srcset="/images/hydrogen.png, /images/hydrogen.png 1.5x, /images/hydrogen.png 2x"
        data-sizes="auto"
        alt="/images/hydrogen.png"
        title="/images/hydrogen.png" /><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="H2oLo"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/hydrogen.png"
        data-srcset="/images/hydrogen.png, /images/hydrogen.png 1.5x, /images/hydrogen.png 2x"
        data-sizes="auto"
        alt="/images/hydrogen.png"
        title="/images/hydrogen.png" /><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Java8实战</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-category"><a href="/categories/java%E7%BC%96%E7%A8%8B/"><i class="far fa-folder fa-fw"></i>Java编程</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2025-04-16">2025-04-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 11786 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 24 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1基础知识">1.基础知识</a>
      <ul>
        <li><a href="#11-流处理">1.1 流处理</a></li>
        <li><a href="#12行为参数化">1.2行为参数化</a></li>
        <li><a href="#13-并行与共享的可变数据">1.3 并行与共享的可变数据</a></li>
        <li><a href="#14-函数">1.4 函数</a></li>
        <li><a href="#15-stream-api与collection-api">1.5 Stream API与Collection API</a></li>
        <li><a href="#16-默认方法">1.6 默认方法</a></li>
      </ul>
    </li>
    <li><a href="#2lambda表达式">2.Lambda表达式</a>
      <ul>
        <li><a href="#21-函数式接口">2.1 函数式接口</a></li>
        <li><a href="#22-类型检查推断和限制">2.2 类型检查、推断和限制</a>
          <ul>
            <li><a href="#221-使用局部变量">2.2.1 使用局部变量</a></li>
            <li><a href="#222-方法引用">2.2.2 方法引用</a></li>
            <li><a href="#223-复合">2.2.3 复合</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#3引入流">3.引入流</a>
      <ul>
        <li><a href="#31-流操作">3.1 流操作</a>
          <ul>
            <li><a href="#311-中间操作">3.1.1 中间操作</a></li>
            <li><a href="#312-终端操作">3.1.2 终端操作</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4使用流">4.使用流</a>
      <ul>
        <li><a href="#41-筛选和切片">4.1 筛选和切片</a></li>
        <li><a href="#42-映射">4.2 映射</a></li>
        <li><a href="#43-查找和匹配">4.3 查找和匹配</a></li>
        <li><a href="#44-归约">4.4 归约</a></li>
        <li><a href="#45-原始类型流特化">4.5 原始类型流特化</a></li>
        <li><a href="#46-创建流">4.6 创建流</a></li>
      </ul>
    </li>
    <li><a href="#5用流收集数据">5.用流收集数据</a>
      <ul>
        <li><a href="#51-collectors预定义收集器">5.1 Collectors预定义收集器</a></li>
        <li><a href="#52-广义的归约汇总">5.2 广义的归约汇总</a></li>
        <li><a href="#53-分组">5.3 分组</a></li>
        <li><a href="#54-分区">5.4 分区</a></li>
        <li><a href="#55-收集器接口">5.5 收集器接口</a>
          <ul>
            <li><a href="#551-supplier建立新的结果容器">5.5.1 supplier建立新的结果容器</a></li>
            <li><a href="#552-accumulator将元素添加到结果容器">5.5.2 accumulator将元素添加到结果容器</a></li>
            <li><a href="#553-finisher对结果容器应用最终转换">5.5.3 finisher对结果容器应用最终转换</a></li>
            <li><a href="#554-combiner合并两个结果容器">5.5.4 combiner合并两个结果容器</a></li>
            <li><a href="#555-characteristics方法">5.5.5 characteristics方法</a></li>
            <li><a href="#556-自定义收集">5.5.6 自定义收集</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#6并行数据处理与性能">6.并行数据处理与性能</a>
      <ul>
        <li><a href="#61-将顺序流转换为并行流">6.1 将顺序流转换为并行流</a></li>
        <li><a href="#62-正确使用并行">6.2 正确使用并行</a></li>
        <li><a href="#63-forkjoin框架">6.3 Fork/Join框架</a>
          <ul>
            <li><a href="#631-recursivetask">6.3.1 RecursiveTask</a></li>
            <li><a href="#632-使用forkjoin的最佳做法">6.3.2 使用Fork/Join的最佳做法</a></li>
            <li><a href="#633-工作窃取">6.3.3 工作窃取</a></li>
          </ul>
        </li>
        <li><a href="#64-spliterator可分迭代器">6.4 Spliterator可分迭代器</a>
          <ul>
            <li><a href="#641-拆分过程">6.4.1 拆分过程</a></li>
            <li><a href="#642-自定义spliterator">6.4.2 自定义Spliterator</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#7-重构测试和调试">7. 重构、测试和调试</a>
      <ul>
        <li><a href="#71-重构">7.1 重构</a>
          <ul>
            <li><a href="#711-使用lambda替换匿名类">7.1.1 使用Lambda替换匿名类</a></li>
            <li><a href="#712-方法引用代替lambda">7.1.2 方法引用代替Lambda</a></li>
            <li><a href="#713-从命令式的数据处理切换到stream">7.1.3 从命令式的数据处理切换到Stream</a></li>
            <li><a href="#714重构模式">7.1.4重构模式</a></li>
          </ul>
        </li>
        <li><a href="#72-使用lambda重构面向对象的设计模式">7.2 使用Lambda重构面向对象的设计模式</a>
          <ul>
            <li><a href="#721-策略模式">7.2.1 策略模式</a></li>
            <li><a href="#722-模板方法">7.2.2 模板方法</a></li>
            <li><a href="#723-观察者模式">7.2.3 观察者模式</a></li>
            <li><a href="#724-责任链模式">7.2.4 责任链模式</a></li>
            <li><a href="#725-工厂模式">7.2.5 工厂模式</a></li>
          </ul>
        </li>
        <li><a href="#72-测试lambda">7.2 测试Lambda</a></li>
        <li><a href="#73-调试">7.3 调试</a></li>
      </ul>
    </li>
    <li><a href="#8默认方法">8.默认方法</a></li>
    <li><a href="#9optional">9.Optional</a></li>
    <li><a href="#10completablefuture组合式异步编程">10.CompletableFuture组合式异步编程</a></li>
    <li><a href="#11新的日期api">11.新的日期API</a>
      <ul>
        <li><a href="#111-localdate和localtime">11.1 LocalDate和LocalTime</a></li>
        <li><a href="#112-instant">11.2 Instant</a></li>
        <li><a href="#113-duration或period">11.3 Duration或Period</a></li>
        <li><a href="#114-操纵解析和格式化日期">11.4 操纵、解析和格式化日期</a>
          <ul>
            <li><a href="#1141-使用temporaladjuster">11.4.1 使用TemporalAdjuster</a></li>
            <li><a href="#1142-datetimeformatter">11.4.2 DateTimeFormatter</a></li>
          </ul>
        </li>
        <li><a href="#115-处理不同的时区和历法">11.5 处理不同的时区和历法</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="1基础知识">1.基础知识</h1>
<h2 id="11-流处理">1.1 流处理</h2>
<p>流是一系列数据项，一次只生成一项。可以想象成汽车组装流水线，尽管流水线实际上是一个序列，但不同加工站的运行一般是并行的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 该例子表示把两个文件连接起来创建一个流，然后转换流中的字符，对流中的行进行排序，最后给出流的最后三行。</span>
<span class="c1"># 这几个命令在Unix中是同时执行的。</span>
cat file1 file2 <span class="p">|</span> tr <span class="s2">&#34;[a-z]&#34;</span> <span class="s2">&#34;[A-Z]&#34;</span> <span class="p">|</span> sort <span class="p">|</span> tail -3
</code></pre></td></tr></table>
</div>
</div><h2 id="12行为参数化">1.2行为参数化</h2>
<p>Stream API是构建在通过传递代码使得操作行为实现参数化的思想上。</p>
<p>比方说，你有一堆发票代码，格式类似于2013UK0001、2014US0002……前四位数代表年份， 接下来两个字母代表国家，最后四位是客户的代码。你可能想按照年份、客户代码，甚至国家来 对发票进行排序。你真正想要的是，能够给sort命令一个参数让用户定义顺序：给sort命令传 递一段独立代码。<strong>Java8增加了把代码作为参数传递给另一个方法的能力</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96.jpg"
        data-srcset="/images/Java/%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96.jpg, /images/Java/%e8%a1%8c%e4%b8%ba%e5%8f%82%e6%95%b0%e5%8c%96.jpg 1.5x, /images/Java/%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96.jpg 2x"
        data-sizes="auto"
        alt="/images/Java/%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96.jpg"
        title="行为参数化" /></p>
<h2 id="13-并行与共享的可变数据">1.3 并行与共享的可变数据</h2>
<blockquote>
<p>没有共享的可变数据和将方法和函数即代码传递给其他方法的能力是函数式编程范式的基石。函数式编程中的函数的主要意思是“把函数作为一等值”，也即“执行时在元素之间无互动”。</p>
</blockquote>
<h2 id="14-函数">1.4 函数</h2>
<ul>
<li>Java8允许把方法和函数作为一等公民（可传递的值）。让方法作为值构成了其他若干Java8功能的基础。</li>
<li>Java8可以传递方法引用，以前只能传递对象引用</li>
<li>谓词（predicate）：在数学上常常用来代表一个类似函数的东西，他接受一个参数值，并返回true或false。</li>
<li><strong>如果Lambda的长度多于几行，它的行为也不是一目了然的话，应该用方法引用来指向一个有描述性名称的方法，而不是使用匿名的Lambda。</strong></li>
</ul>
<h2 id="15-stream-api与collection-api">1.5 Stream API与Collection API</h2>
<ul>
<li>用集合循环一个个去迭代再处理元素称为<strong>外部迭代</strong>，流处理是在库内部进行的，称为<strong>内部迭代</strong>。</li>
<li>流的并行比使用线程同步更不易出错，流天生具有利用多核的优势。</li>
<li><strong>Collection主要是为了存储和访问数据，而Stream则主要用于描述对数据的计算</strong>。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e6%b5%81%e5%b9%b6%e8%a1%8c.png"
        data-srcset="/images/Java/%E6%B5%81%E5%B9%B6%E8%A1%8C.png, /images/Java/%e6%b5%81%e5%b9%b6%e8%a1%8c.png 1.5x, /images/Java/%E6%B5%81%E5%B9%B6%E8%A1%8C.png 2x"
        data-sizes="auto"
        alt="/images/Java/%E6%B5%81%E5%B9%B6%E8%A1%8C.png"
        title="流并行" /></p>
<h2 id="16-默认方法">1.6 默认方法</h2>
<p>设计默认方法的目的在于改变已发布的接口而不破坏已有的实现。例如Java8中List新增的默认方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">default</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Object</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="o">(</span><span class="n">Comparator</span><span class="o">)</span> <span class="n">c</span><span class="o">);</span>
        <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">listIterator</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">e</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="n">i</span><span class="o">.</span><span class="na">set</span><span class="o">((</span><span class="n">E</span><span class="o">)</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><em>但一个类可以实现多个接口，如果在好几个接口里有多个默认实现，某种程度上意味着Java有了多重继承。Java用一些限制来避免出现类似C++中的菱形继承问题。</em></p>
<h1 id="2lambda表达式">2.Lambda表达式</h1>
<p>可以把Lambda表达式看做匿名函数，也就是没有声明名称的方法，和匿名类一样可以作为参数传递给一个方法，它有参数列表、函数主体、返回类型、还有可能有可以抛出的异常列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 表达式就是Lambda的返回值
</span><span class="c1"></span><span class="o">(</span><span class="n">parameters</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">expression</span>
<span class="o">(</span><span class="n">parameters</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">statements</span><span class="o">;}</span>
<span class="o">(</span><span class="n">1</span><span class="o">).()</span> <span class="o">-&gt;</span> <span class="o">{}</span>
<span class="o">(</span><span class="n">2</span><span class="o">).()</span> <span class="o">-&gt;</span> <span class="s">&#34;hello world&#34;</span>
<span class="o">(</span><span class="n">3</span><span class="o">).()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">return</span> <span class="s">&#34;hello world&#34;</span><span class="o">;}</span>
<span class="o">(</span><span class="n">4</span><span class="o">).(</span><span class="n">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="s">&#34;hello&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span> <span class="c1">//无效，不应有return
</span><span class="c1"></span><span class="o">(</span><span class="n">5</span><span class="o">).(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="s">&#34;IronMan&#34;</span><span class="o">;</span> <span class="o">}</span> <span class="c1">//无效，显示返回要加上return
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><h2 id="21-函数式接口">2.1 函数式接口</h2>
<p><strong>函数式接口中的抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名成为函数描述符。</strong></p>
<blockquote>
<p>任何函数式接口都不允许抛出受检异常。</p>
</blockquote>
<h2 id="22-类型检查推断和限制">2.2 类型检查、推断和限制</h2>
<p>Lambda的类型是从使用Lambda的上下文推断出来的。<strong>如果Lambda表达式抛出一个异常，那么抽象方法所声明的throws语句也必须与之匹配</strong></p>
<blockquote>
<p>**特殊的void兼容规则：**如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容。</p>
</blockquote>
<h3 id="221-使用局部变量">2.2.1 使用局部变量</h3>
<p>Lambda表达式允许使用自由变量（在外层作用域中定义的变量），就像匿名类一样，它们被称作Lambda捕获。<strong>Lambda可以没有限制地捕获实例变量和静态变量，但局部变量必须显式声明为final或逻辑上是final的，也就是只能捕获局部变量一次</strong></p>
<blockquote>
<p><strong>闭包</strong></p>
<p>闭包是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。但Lambda访问非本地变量有必须是隐式最终的限制，因为局部变量保存在栈上，是线程私有的，线程访问非本地局部变量时实际上是访问它的副本。可以认为Lambda对值封闭，而不是对变量封闭。</p>
</blockquote>
<h3 id="222-方法引用">2.2.2 方法引用</h3>
<p>如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。  可以把方法引用看作针对仅仅涉及单一方法的Lambda的语法糖</p>
<ul>
<li>指向静态方法的方法引用。<code>Integer::parseInt</code></li>
<li>指向任意类型实例方法的方法引用。<code>String::length</code></li>
<li>指向现有对象的实例方法的方法引用。在 Lambda 中 调 用 一 个 已 经 存 在 的 外 部 对 象 中 的 方 法 。 例 如 ， Lambda 表 达 式
<code>()-&gt;expensiveTransaction.getValue()</code>可以写作<code>expensiveTransaction::getValue</code></li>
</ul>
<h3 id="223-复合">2.2.3 复合</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 1.比较器链。如先按重量递减排序，两个苹果一样重时，再按国家排序
</span><span class="c1"></span><span class="n">inventory</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getWeoght</span><span class="o">))</span>
    <span class="o">.</span><span class="na">reversed</span><span class="o">()</span>
    <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getCountry</span><span class="o">)</span>
<span class="c1">// 2.谓词复合。and和or是按照在表达式链中的位置从左向右确定优先级的。a.or(b).and(c)可以看做(a || b) &amp;&amp; c
</span><span class="c1"></span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;</span> <span class="n">redAndHeavyAppleOrGreen</span> <span class="o">=</span> <span class="n">redApple</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">getWeight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">150</span><span class="o">)</span>
											<span class="o">.</span><span class="na">or</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="s">&#34;green&#34;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getColor</span><span class="o">()));</span>
<span class="c1">// 3.函数复合。
</span><span class="c1"></span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">2</span><span class="o">;</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">g</span><span class="o">);</span> <span class="c1">//数学上写作g(f(x))
</span><span class="c1"></span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="n">g</span><span class="o">);</span> <span class="c1">//数学上写作f(g(x))
</span><span class="c1"></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="3引入流">3.引入流</h1>
<p>流：从支持数据处理操作的源生成的元素序列。<strong>流只能消费一次且是按需计算的。</strong></p>
<ul>
<li>元素序列：访问特定元素类型的一组有序值 ，集合讲的是数据，流讲的是计算 。</li>
<li>源：从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li>
<li>数据处理操作：流操作可以顺序执行，也可并行执行 。</li>
<li>流水线：很多流操作本身会返回一个流 ，流水线的操作可以看作对数据源进行数据库式查询。</li>
<li>内部迭代：流的迭代操作是在背后进行的。 <strong>Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。</strong></li>
</ul>
<h2 id="31-流操作">3.1 流操作</h2>
<p>可以连接起来的流操作称为中间操作，关闭流的操作称为操作。  <strong>流的流水线理念类似于建造者模式。</strong></p>
<h3 id="311-中间操作">3.1.1 中间操作</h3>
<p>中间操作会返回另一个流。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理，因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。</p>
<h3 id="312-终端操作">3.1.2 终端操作</h3>
<p>终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、 Integer，甚至void。</p>
<h1 id="4使用流">4.使用流</h1>
<h2 id="41-筛选和切片">4.1 筛选和切片</h2>
<p>filter</p>
<h2 id="42-映射">4.2 映射</h2>
<p>map、flatMap</p>
<h2 id="43-查找和匹配">4.3 查找和匹配</h2>
<p>allMatch、anyMatch、noneMatch、findFirst、findAny</p>
<h2 id="44-归约">4.4 归约</h2>
<p>reduce</p>
<blockquote>
<p><strong>归约方法的优势与并行化</strong></p>
<p>相比于逐步迭代，使用reduce的好处在于，这里的迭代被内部迭代抽象化了，这让内部实现得以选择并行执行reduce操作。而迭代式求和例子要更新共享变量sum，这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争消了并行本应带来的
性能提升。这种计算的并行化需要另一种办法法：将输入分块，分块求和，最后合并起来。但这样的代码看起来就完全不一样了。但要并行执行需要代价，传递给reduce的Lambda不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行。</p>
</blockquote>
<h2 id="45-原始类型流特化">4.5 原始类型流特化</h2>
<p>为了避免拆装箱操作带来的性能损耗，Java8引入了三个原始类型特化流接口（Optional也有）来解决这个问题：IntStream、DoubleStream和LongStream。</p>
<h2 id="46-创建流">4.6 创建流</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">//由值创建流
</span><span class="c1"></span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Java 8 &#34;</span><span class="o">,</span> <span class="s">&#34;Lambdas &#34;</span><span class="o">,</span> <span class="s">&#34;In &#34;</span><span class="o">,</span> <span class="s">&#34;Action&#34;</span><span class="o">);</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">emptyStream</span> <span class="o">=</span> <span class="n">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
<span class="c1">//由数组创建流
</span><span class="c1"></span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span><span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">7</span><span class="o">,</span> <span class="n">11</span><span class="o">,</span> <span class="n">13</span><span class="o">};</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">numbers</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>
<span class="c1">//由函数生成流
</span><span class="c1"></span><span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">},</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">t</span><span class="o">[</span><span class="n">1</span><span class="o">],</span><span class="n">t</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">t</span><span class="o">[</span><span class="n">1</span><span class="o">]})</span>
<span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">10</span><span class="o">)</span>
<span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">[</span><span class="n">0</span><span class="o">])</span>
<span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="c1">// ===相比于iterate，generate是有状态的
</span><span class="c1"></span><span class="n">IntSupplier</span> <span class="n">fib</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntSupplier</span><span class="o">(){</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAsInt</span><span class="o">(){</span>
<span class="kt">int</span> <span class="n">oldPrevious</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">previous</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">previous</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">current</span><span class="o">;</span>
<span class="k">this</span><span class="o">.</span><span class="na">previous</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">current</span><span class="o">;</span>
<span class="k">this</span><span class="o">.</span><span class="na">current</span> <span class="o">=</span> <span class="n">nextValue</span><span class="o">;</span>
<span class="k">return</span> <span class="n">oldPrevious</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">};</span>
<span class="n">IntStream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="n">fib</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">10</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="c1">//=====
</span></code></pre></td></tr></table>
</div>
</div><h1 id="5用流收集数据">5.用流收集数据</h1>
<h2 id="51-collectors预定义收集器">5.1 Collectors预定义收集器</h2>
<ul>
<li><code>Collectors.counting</code>计数</li>
<li><code>Collectors.max(min)By</code> 查找最大值和最小值</li>
<li><code>Collectors.summingInt</code>，<code>Collectors.averagingInt(Long|Double)</code>汇总</li>
<li><code>Collectors.summarizingInt(Long|Double)</code>一次性取总和、平均值、最大值和最小值</li>
<li><code>Collectors.joining(可选分隔符)</code>连接字符串</li>
</ul>
<h2 id="52-广义的归约汇总">5.2 广义的归约汇总</h2>
<p><code>Collectors.reducing</code>：把流中的第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数。注意可能会返回<code>null</code>。</p>
<blockquote>
<p><strong>收集与归约</strong></p>
<p>reduce方法旨在把两个值结合起来生成一个新值，是一个不可变的归约。collect是改变容器从而累积要输出的结果。</p>
</blockquote>
<h2 id="53-分组">5.3 分组</h2>
<ul>
<li>一级分组。<code>groupingBy(f)</code>，f是分类函数实际上是<code>groupingBy(f, toList())</code>的简便写法</li>
<li>n级分组，可以将collector类型传递给前一个<code>groupingBy</code>的第二个参数，以此类推。</li>
<li>按子组收集数据，<code>groupingBy</code>的第二个收集器可以是任何类型</li>
<li>把收集器的结果转换为另一种类型。<code>Collectors.collectingAndThen</code></li>
<li><code>mapping</code></li>
</ul>
<h2 id="54-分区">5.4 分区</h2>
<p><code>partitioningBy</code>分区是分组的特殊情况，由一个谓词作为分类函数，他称为分区函数。</p>
<h2 id="55-收集器接口">5.5 收集器接口</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">java.util.stream</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.EnumSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Objects</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BinaryOperator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="c1">// A compilation test for the code snippets in this class-level javadoc can be found at:
</span><span class="c1">// test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/CollectorExample.java
</span><span class="c1">// The test needs to be updated if the examples in this javadoc change or new examples are added.
</span><span class="c1"></span>
<span class="cm">/**
</span><span class="cm"> * A &lt;a href=&#34;package-summary.html#Reduction&#34;&gt;mutable reduction operation&lt;/a&gt; that
</span><span class="cm"> * accumulates input elements into a mutable result container, optionally transforming
</span><span class="cm"> * the accumulated result into a final representation after all input elements
</span><span class="cm"> * have been processed.  Reduction operations can be performed either sequentially
</span><span class="cm"> * or in parallel.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Examples of mutable reduction operations include:
</span><span class="cm"> * accumulating elements into a {@code Collection}; concatenating
</span><span class="cm"> * strings using a {@code StringBuilder}; computing summary information about
</span><span class="cm"> * elements such as sum, min, max, or average; computing &#34;pivot table&#34; summaries
</span><span class="cm"> * such as &#34;maximum valued transaction by seller&#34;, etc.  The class {@link Collectors}
</span><span class="cm"> * provides implementations of many common mutable reductions.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A {@code Collector} is specified by four functions that work together to
</span><span class="cm"> * accumulate entries into a mutable result container, and optionally perform
</span><span class="cm"> * a final transform on the result.  They are: &lt;ul&gt;
</span><span class="cm"> *     &lt;li&gt;creation of a new result container ({@link #supplier()})&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;incorporating a new data element into a result container ({@link #accumulator()})&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;combining two result containers into one ({@link #combiner()})&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;performing an optional final transform on the container ({@link #finisher()})&lt;/li&gt;
</span><span class="cm"> * &lt;/ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Collectors also have a set of characteristics, such as
</span><span class="cm"> * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a
</span><span class="cm"> * reduction implementation to provide better performance.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;A sequential implementation of a reduction using a collector would
</span><span class="cm"> * create a single result container using the supplier function, and invoke the
</span><span class="cm"> * accumulator function once for each input element.  A parallel implementation
</span><span class="cm"> * would partition the input, create a result container for each partition,
</span><span class="cm"> * accumulate the contents of each partition into a subresult for that partition,
</span><span class="cm"> * and then use the combiner function to merge the subresults into a combined
</span><span class="cm"> * result.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;To ensure that sequential and parallel executions produce equivalent
</span><span class="cm"> * results, the collector functions must satisfy an &lt;em&gt;identity&lt;/em&gt; and an
</span><span class="cm"> * &lt;a href=&#34;package-summary.html#Associativity&#34;&gt;associativity&lt;/a&gt; constraints.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;The identity constraint says that for any partially accumulated result,
</span><span class="cm"> * combining it with an empty result container must produce an equivalent
</span><span class="cm"> * result.  That is, for a partially accumulated result {@code a} that is the
</span><span class="cm"> * result of any series of accumulator and combiner invocations, {@code a} must
</span><span class="cm"> * be equivalent to {@code combiner.apply(a, supplier.get())}.
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;The associativity constraint says that splitting the computation must
</span><span class="cm"> * produce an equivalent result.  That is, for any input elements {@code t1}
</span><span class="cm"> * and {@code t2}, the results {@code r1} and {@code r2} in the computation
</span><span class="cm"> * below must be equivalent:
</span><span class="cm"> * &lt;pre&gt;{@code
</span><span class="cm"> *     A a1 = supplier.get();
</span><span class="cm"> *     accumulator.accept(a1, t1);
</span><span class="cm"> *     accumulator.accept(a1, t2);
</span><span class="cm"> *     R r1 = finisher.apply(a1);  // result without splitting
</span><span class="cm"> *
</span><span class="cm"> *     A a2 = supplier.get();
</span><span class="cm"> *     accumulator.accept(a2, t1);
</span><span class="cm"> *     A a3 = supplier.get();
</span><span class="cm"> *     accumulator.accept(a3, t2);
</span><span class="cm"> *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
</span><span class="cm"> * } &lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;For collectors that do not have the {@code UNORDERED} characteristic,
</span><span class="cm"> * two accumulated results {@code a1} and {@code a2} are equivalent if
</span><span class="cm"> * {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered
</span><span class="cm"> * collectors, equivalence is relaxed to allow for non-equality related to
</span><span class="cm"> * differences in order.  (For example, an unordered collector that accumulated
</span><span class="cm"> * elements to a {@code List} would consider two lists equivalent if they
</span><span class="cm"> * contained the same elements, ignoring order.)
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Libraries that implement reduction based on {@code Collector}, such as
</span><span class="cm"> * {@link Stream#collect(Collector)}, must adhere to the following constraints:
</span><span class="cm"> * &lt;ul&gt;
</span><span class="cm"> *     &lt;li&gt;The first argument passed to the accumulator function, both
</span><span class="cm"> *     arguments passed to the combiner function, and the argument passed to the
</span><span class="cm"> *     finisher function must be the result of a previous invocation of the
</span><span class="cm"> *     result supplier, accumulator, or combiner functions.&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;The implementation should not do anything with the result of any of
</span><span class="cm"> *     the result supplier, accumulator, or combiner functions other than to
</span><span class="cm"> *     pass them again to the accumulator, combiner, or finisher functions,
</span><span class="cm"> *     or return them to the caller of the reduction operation.&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;If a result is passed to the combiner or finisher
</span><span class="cm"> *     function, and the same object is not returned from that function, it is
</span><span class="cm"> *     never used again.&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;Once a result is passed to the combiner or finisher function, it
</span><span class="cm"> *     is never passed to the accumulator function again.&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;For non-concurrent collectors, any result returned from the result
</span><span class="cm"> *     supplier, accumulator, or combiner functions must be serially
</span><span class="cm"> *     thread-confined.  This enables collection to occur in parallel without
</span><span class="cm"> *     the {@code Collector} needing to implement any additional synchronization.
</span><span class="cm"> *     The reduction implementation must manage that the input is properly
</span><span class="cm"> *     partitioned, that partitions are processed in isolation, and combining
</span><span class="cm"> *     happens only after accumulation is complete.&lt;/li&gt;
</span><span class="cm"> *     &lt;li&gt;For concurrent collectors, an implementation is free to (but not
</span><span class="cm"> *     required to) implement reduction concurrently.  A concurrent reduction
</span><span class="cm"> *     is one where the accumulator function is called concurrently from
</span><span class="cm"> *     multiple threads, using the same concurrently-modifiable result container,
</span><span class="cm"> *     rather than keeping the result isolated during accumulation.
</span><span class="cm"> *     A concurrent reduction should only be applied if the collector has the
</span><span class="cm"> *     {@link Characteristics#UNORDERED} characteristics or if the
</span><span class="cm"> *     originating data is unordered.&lt;/li&gt;
</span><span class="cm"> * &lt;/ul&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;In addition to the predefined implementations in {@link Collectors}, the
</span><span class="cm"> * static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}
</span><span class="cm"> * can be used to construct collectors.  For example, you could create a collector
</span><span class="cm"> * that accumulates widgets into a {@code TreeSet} with:
</span><span class="cm"> *
</span><span class="cm"> * &lt;pre&gt;{@code
</span><span class="cm"> *     Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =
</span><span class="cm"> *         Collector.of(TreeSet::new, TreeSet::add,
</span><span class="cm"> *                      (left, right) -&gt; { left.addAll(right); return left; });
</span><span class="cm"> * }&lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * (This behavior is also implemented by the predefined collector
</span><span class="cm"> * {@link Collectors#toCollection(Supplier)}).
</span><span class="cm"> *
</span><span class="cm"> * @apiNote
</span><span class="cm"> * Performing a reduction operation with a {@code Collector} should produce a
</span><span class="cm"> * result equivalent to:
</span><span class="cm"> * &lt;pre&gt;{@code
</span><span class="cm"> *     A container = collector.supplier().get();
</span><span class="cm"> *     for (T t : data)
</span><span class="cm"> *         collector.accumulator().accept(container, t);
</span><span class="cm"> *     return collector.finisher().apply(container);
</span><span class="cm"> * }&lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;However, the library is free to partition the input, perform the reduction
</span><span class="cm"> * on the partitions, and then use the combiner function to combine the partial
</span><span class="cm"> * results to achieve a parallel reduction.  (Depending on the specific reduction
</span><span class="cm"> * operation, this may perform better or worse, depending on the relative cost
</span><span class="cm"> * of the accumulator and combiner functions.)
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;Collectors are designed to be &lt;em&gt;composed&lt;/em&gt;; many of the methods
</span><span class="cm"> * in {@link Collectors} are functions that take a collector and produce
</span><span class="cm"> * a new collector.  For example, given the following collector that computes
</span><span class="cm"> * the sum of the salaries of a stream of employees:
</span><span class="cm"> *
</span><span class="cm"> * &lt;pre&gt;{@code
</span><span class="cm"> *     Collector&lt;Employee, ?, Integer&gt; summingSalaries
</span><span class="cm"> *         = Collectors.summingInt(Employee::getSalary))
</span><span class="cm"> * }&lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * If we wanted to create a collector to tabulate the sum of salaries by
</span><span class="cm"> * department, we could reuse the &#34;sum of salaries&#34; logic using
</span><span class="cm"> * {@link Collectors#groupingBy(Function, Collector)}:
</span><span class="cm"> *
</span><span class="cm"> * &lt;pre&gt;{@code
</span><span class="cm"> *     Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept
</span><span class="cm"> *         = Collectors.groupingBy(Employee::getDepartment, summingSalaries);
</span><span class="cm"> * }&lt;/pre&gt;
</span><span class="cm"> *
</span><span class="cm"> * @see Stream#collect(Collector)
</span><span class="cm"> * @see Collectors
</span><span class="cm"> *
</span><span class="cm"> * @param &lt;T&gt; the type of input elements to the reduction operation
</span><span class="cm"> * @param &lt;A&gt; the mutable accumulation type of the reduction operation (often
</span><span class="cm"> *            hidden as an implementation detail)
</span><span class="cm"> * @param &lt;R&gt; the result type of the reduction operation
</span><span class="cm"> * @since 1.8
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * 创建并返回新的可变结果容器的函数。
</span><span class="cm">     * 返回值：返回新的可变结果容器的函数
</span><span class="cm">     */</span>
    <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * A function that folds a value into a mutable result container.
</span><span class="cm">     *
</span><span class="cm">     * @return a function which folds a value into a mutable result container
</span><span class="cm">     */</span>
    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * A function that accepts two partial results and merges them.  The
</span><span class="cm">     * combiner function may fold state from one argument into the other and
</span><span class="cm">     * return that, or may return a new result container.
</span><span class="cm">     *
</span><span class="cm">     * @return a function which combines two partial results into a combined
</span><span class="cm">     * result
</span><span class="cm">     */</span>
    <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Perform the final transformation from the intermediate accumulation type
</span><span class="cm">     * {@code A} to the final result type {@code R}.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;If the characteristic {@code IDENTITY_FINISH} is
</span><span class="cm">     * set, this function may be presumed to be an identity transform with an
</span><span class="cm">     * unchecked cast from {@code A} to {@code R}.
</span><span class="cm">     *
</span><span class="cm">     * @return a function which transforms the intermediate result to the final
</span><span class="cm">     * result
</span><span class="cm">     */</span>
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Returns a {@code Set} of {@code Collector.Characteristics} indicating
</span><span class="cm">     * the characteristics of this Collector.  This set should be immutable.
</span><span class="cm">     *
</span><span class="cm">     * @return an immutable set of collector characteristics
</span><span class="cm">     */</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">();</span>

    <span class="cm">/**
</span><span class="cm">     * Returns a new {@code Collector} described by the given {@code supplier},
</span><span class="cm">     * {@code accumulator}, and {@code combiner} functions.  The resulting
</span><span class="cm">     * {@code Collector} has the {@code Collector.Characteristics.IDENTITY_FINISH}
</span><span class="cm">     * characteristic.
</span><span class="cm">     *
</span><span class="cm">     * @param supplier The supplier function for the new collector
</span><span class="cm">     * @param accumulator The accumulator function for the new collector
</span><span class="cm">     * @param combiner The combiner function for the new collector
</span><span class="cm">     * @param characteristics The collector characteristics for the new
</span><span class="cm">     *                        collector
</span><span class="cm">     * @param &lt;T&gt; The type of input elements for the new collector
</span><span class="cm">     * @param &lt;R&gt; The type of intermediate accumulation result, and final result,
</span><span class="cm">     *           for the new collector
</span><span class="cm">     * @throws NullPointerException if any argument is null
</span><span class="cm">     * @return the new {@code Collector}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                              <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                                              <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">,</span>
                                              <span class="n">Characteristics</span><span class="o">...</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">supplier</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">accumulator</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">combiner</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">characteristics</span><span class="o">);</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="n">cs</span> <span class="o">=</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
                                  <span class="o">?</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">CH_ID</span>
                                  <span class="o">:</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">,</span>
                                                                           <span class="n">characteristics</span><span class="o">));</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">CollectorImpl</span><span class="o">&lt;&gt;(</span><span class="n">supplier</span><span class="o">,</span> <span class="n">accumulator</span><span class="o">,</span> <span class="n">combiner</span><span class="o">,</span> <span class="n">cs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Returns a new {@code Collector} described by the given {@code supplier},
</span><span class="cm">     * {@code accumulator}, {@code combiner}, and {@code finisher} functions.
</span><span class="cm">     *
</span><span class="cm">     * @param supplier The supplier function for the new collector
</span><span class="cm">     * @param accumulator The accumulator function for the new collector
</span><span class="cm">     * @param combiner The combiner function for the new collector
</span><span class="cm">     * @param finisher The finisher function for the new collector
</span><span class="cm">     * @param characteristics The collector characteristics for the new
</span><span class="cm">     *                        collector
</span><span class="cm">     * @param &lt;T&gt; The type of input elements for the new collector
</span><span class="cm">     * @param &lt;A&gt; The intermediate accumulation type of the new collector
</span><span class="cm">     * @param &lt;R&gt; The final result type of the new collector
</span><span class="cm">     * @throws NullPointerException if any argument is null
</span><span class="cm">     * @return the new {@code Collector}
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                                 <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                                                 <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">,</span>
                                                 <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">finisher</span><span class="o">,</span>
                                                 <span class="n">Characteristics</span><span class="o">...</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">supplier</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">accumulator</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">combiner</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">finisher</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">characteristics</span><span class="o">);</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">CH_NOID</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">EnumSet</span><span class="o">.</span><span class="na">noneOf</span><span class="o">(</span><span class="n">Characteristics</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">Collections</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">cs</span><span class="o">,</span> <span class="n">characteristics</span><span class="o">);</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Collectors</span><span class="o">.</span><span class="na">CollectorImpl</span><span class="o">&lt;&gt;(</span><span class="n">supplier</span><span class="o">,</span> <span class="n">accumulator</span><span class="o">,</span> <span class="n">combiner</span><span class="o">,</span> <span class="n">finisher</span><span class="o">,</span> <span class="n">cs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Characteristics indicating properties of a {@code Collector}, which can
</span><span class="cm">     * be used to optimize reduction implementations.
</span><span class="cm">     */</span>
    <span class="kd">enum</span> <span class="n">Characteristics</span> <span class="o">{</span>
        <span class="cm">/**
</span><span class="cm">         * Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that
</span><span class="cm">         * the result container can support the accumulator function being
</span><span class="cm">         * called concurrently with the same result container from multiple
</span><span class="cm">         * threads.
</span><span class="cm">         *
</span><span class="cm">         * &lt;p&gt;If a {@code CONCURRENT} collector is not also {@code UNORDERED},
</span><span class="cm">         * then it should only be evaluated concurrently if applied to an
</span><span class="cm">         * unordered data source.
</span><span class="cm">         */</span>
        <span class="n">CONCURRENT</span><span class="o">,</span>

        <span class="cm">/**
</span><span class="cm">         * Indicates that the collection operation does not commit to preserving
</span><span class="cm">         * the encounter order of input elements.  (This might be true if the
</span><span class="cm">         * result container has no intrinsic order, such as a {@link Set}.)
</span><span class="cm">         */</span>
        <span class="n">UNORDERED</span><span class="o">,</span>

        <span class="cm">/**
</span><span class="cm">         * Indicates that the finisher function is the identity function and
</span><span class="cm">         * can be elided.  If set, it must be the case that an unchecked cast
</span><span class="cm">         * from A to R will succeed.
</span><span class="cm">         */</span>
        <span class="n">IDENTITY_FINISH</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>T是流中要收集的项目的泛型</li>
<li>A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象</li>
<li>R是收集操作得到的对象的类型</li>
<li><code>characteristics</code>方法提供了一系列特征，告诉collect方法在执行归约操作的时候可以应用哪些优化，如并行化。</li>
</ul>
<h3 id="551-supplier建立新的结果容器">5.5.1 supplier建立新的结果容器</h3>
<p>该方法返回一个结果为空的supplier，也就是一个无参函数，在调用是它会创建一个空的累加器实例，供数据收集过程使用，所以，在对空流执行操作的时候，这个空的累加器也代表了收集过程的结果。</p>
<h3 id="552-accumulator将元素添加到结果容器">5.5.2 accumulator将元素添加到结果容器</h3>
<p>该方法返回执行归约操作的函数。该函数返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现便利元素的效果。</p>
<h3 id="553-finisher对结果容器应用最终转换">5.5.3 finisher对结果容器应用最终转换</h3>
<p>该方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。如果结果无需转换，则只需返回<code>identity</code>函数</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e9%a1%ba%e5%ba%8f%e5%bd%92%e7%ba%a6.png"
        data-srcset="/images/Java/%E9%A1%BA%E5%BA%8F%E5%BD%92%E7%BA%A6.png, /images/Java/%e9%a1%ba%e5%ba%8f%e5%bd%92%e7%ba%a6.png 1.5x, /images/Java/%E9%A1%BA%E5%BA%8F%E5%BD%92%E7%BA%A6.png 2x"
        data-sizes="auto"
        alt="/images/Java/%E9%A1%BA%E5%BA%8F%E5%BD%92%E7%BA%A6.png"
        title="顺序归约" /></p>
<h3 id="554-combiner合并两个结果容器">5.5.4 combiner合并两个结果容器</h3>
<p>该方法返回一个供归约操作使用的函数，它定义了对流的各个子部分<strong>进行并行处理时</strong>，各个子部分归约所得的累加器要如何合并。对于<code>toList</code>而言：只是简单的把从流的第二个部分收集到的项目列表添加到遍历第一部分时得到的列表后面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="o">?,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">toList</span><span class="o">()</span> <span class="o">{</span>
     <span class="k">return</span> <span class="k">new</span> <span class="n">CollectorImpl</span><span class="o">&lt;&gt;((</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;)</span> <span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="o">,</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="o">,</span>
                                   <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">left</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">right</span><span class="o">);</span> <span class="k">return</span> <span class="n">left</span><span class="o">;</span> <span class="o">},</span><span class="n">CH_ID</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该方法会用到Java7中引入的分支/合并框架和<code>Spliterator</code>抽象。</p>
<h3 id="555-characteristics方法">5.5.5 characteristics方法</h3>
<p>该方法可以提示流是否可以进行归约以及可使用的优化。</p>
<ul>
<li>
<p><code>UNORDERED</code>&ndash;归约结果不受流中项目的遍历和累积顺序的影响</p>
</li>
<li>
<p><code>CONCUNRRENT</code>&ndash;accumulator函数可以从多个线程同时调用，且收集器可以并行归约流，如果收集器没有标为UNORDERED，它仅在用于无序数据源时才可以进行归约</p>
</li>
<li>
<p><code>IDENTITY_FINISH</code>&ndash;这表明完成器方法返回的函数是一个恒等函数，可以跳过。</p>
</li>
</ul>
<h3 id="556-自定义收集">5.5.6 自定义收集</h3>
<p>对于IDENTITY_FINISH的收集操作，Stream有一个重载的collect方法接受三个函数（supplier,accumulator,combiner）。我们也可以通过实现collector接口定义自己的收集器。</p>
<h1 id="6并行数据处理与性能">6.并行数据处理与性能</h1>
<p>Stream的并行流内部使用流Fork/Join框架。</p>
<h2 id="61-将顺序流转换为并行流">6.1 将顺序流转换为并行流</h2>
<p><code>parallel</code>会将顺序流转化为并行流。但这不代表流本身发生了变化，只是在内部设置流一个<code>boolean</code>标志，表示在调用该方法后的所有操作都并行执行。同样的，可以用<code>sequential</code>方法把流变为顺序流，<strong>但是如果将这个两个方法结合时，会以最后一次调用的为准。</strong></p>
<blockquote>
<p><strong>配置并行流使用的线程池</strong></p>
<p>并行流内部使用流默认的<code>ForkJoinPool</code>，它默认的线程数量就是处理器数量，由<code>Runtime.getRuntime().availableProcessors()</code>获取(实际返回的是可用内核的数量，包括超线程生成的虚拟内核)。</p>
<p>但是也可以自定义<code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;,&quot;数量&quot;)</code>，注意这是一个全局设置，它将影响所有并行流。</p>
</blockquote>
<h2 id="62-正确使用并行">6.2 正确使用并行</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.stream.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParallelStreams</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">iterativeSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sequentialSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="n">1L</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">parallelSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="n">1L</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">parallel</span><span class="o">().</span><span class="na">reduce</span><span class="o">(</span><span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">rangedSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="o">).</span><span class="na">getAsLong</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">parallelRangedSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">parallel</span><span class="o">().</span><span class="na">reduce</span><span class="o">(</span><span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="o">).</span><span class="na">getAsLong</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sideEffectSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Accumulator</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Accumulator</span><span class="o">();</span>
        <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">accumulator</span><span class="o">::</span><span class="n">add</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">total</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sideEffectParallelSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Accumulator</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Accumulator</span><span class="o">();</span>
        <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">parallel</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">accumulator</span><span class="o">::</span><span class="n">add</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">total</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Accumulator</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kn">package</span> <span class="nn">chl</span><span class="o">;</span>

<span class="c1">//===============================================================================================
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyParallelStreams</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">measureSumPerf</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">adder</span><span class="o">,</span> <span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">fastest</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">adder</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="kt">long</span> <span class="n">duration</span> <span class="o">=</span> <span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">1000000</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Result:&#34;</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="n">fastest</span><span class="o">)</span> <span class="n">fastest</span> <span class="o">=</span> <span class="n">duration</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">fastest</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;耗时:&#34;</span> <span class="o">+</span> <span class="n">measureSumPerf</span><span class="o">(</span><span class="n">ParallelStreams</span><span class="o">::</span><span class="n">sideEffectParallelSum</span><span class="o">,</span> <span class="n">10000000</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p><strong>要确保并行正确执行必须保证不存在共享的可变状态</strong>。</p>
<ul>
<li>测量。有时候并行流并不一定比顺序流快。</li>
<li>注意装箱。自动装箱和拆箱操作会大大降低性能，这时候可以使用原始类型流。</li>
<li>有些操作在并行流上的性能比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作。如果不依赖顺序，可以调用unordered方法把有序流变成无序流。</li>
<li>如果一个元素通过流水线的处理成本高，那么使用并行流时性能好的可能性比较大。</li>
<li>对于较小的数据量，选择并行流并不的优先级并不高，因为并行化（分配线程等资源）的开销更高。</li>
<li>考虑流背后的数据结构是否易于分解。可以自定义<code>Spliterator</code>来控制分解过程。</li>
<li>流自身的特点以及流水线中的中间操作修改流的方法，都可能会改变分解过程的性能。一个已知大小的流比未知的更好拆分。</li>
<li>还要考虑终端操作中合并步骤的代价是大是小，如果这一步代价很大，那么组合每个子流的部分结果所产生的的代价就可能会超出通过并行流得到的性能提升。</li>
</ul>
<p><strong>流的数据源可分解性</strong></p>
<table>
<thead>
<tr>
<th>源</th>
<th>可分解性</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>极佳</td>
</tr>
<tr>
<td>LinkedList</td>
<td>差</td>
</tr>
<tr>
<td>IntStream.range</td>
<td>极佳</td>
</tr>
<tr>
<td>Stream.iterate</td>
<td>差</td>
</tr>
<tr>
<td>HashSet</td>
<td>好</td>
</tr>
<tr>
<td>TreeSet</td>
<td>好</td>
</tr>
</tbody>
</table>
<h2 id="63-forkjoin框架">6.3 Fork/Join框架</h2>
<h3 id="631-recursivetask">6.3.1 RecursiveTask</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">5232453952276485270L</span><span class="o">;</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;serial&#34;</span><span class="o">)</span> 
    <span class="n">V</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">V</span> <span class="nf">compute</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">getRawResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setRawResult</span><span class="o">(</span><span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">exec</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">compute</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/forkjoin.png"
        data-srcset="/images/Java/forkjoin.png, /images/Java/forkjoin.png 1.5x, /images/Java/forkjoin.png 2x"
        data-sizes="auto"
        alt="/images/Java/forkjoin.png"
        title="forkjoin" /></p>
<blockquote>
<p>使用多个ForkJoinPool是没有意义的，一般把它实例化一次，然后把实例保存在静态字段中，使之称为单例，这样就可以重用。</p>
</blockquote>
<h3 id="632-使用forkjoin的最佳做法">6.3.2 使用Fork/Join的最佳做法</h3>
<ul>
<li>
<p>对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。</p>
</li>
<li>
<p>不应该在<code>RecursiveTask</code>内部使用<code>ForkJoinPool</code>的<code>invoke</code>方法。相反，应始终直接调用<code>compute</code>或<code>fork</code>方法，只有顺序代码才应该用<code>invoke</code>来启动并行计算。</p>
</li>
<li>
<p>对子任务调用<code>fork</code>方法可以把它排进<code>ForkJoinPool</code>。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用<code>compute</code>低。这样做可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。</p>
</li>
<li>
<p>调试使用分支/合并框架的并行计算可能有点棘手。特别是你平常都在你喜欢的IDE里面看栈跟踪（ stack trace）来找问题，但放在分支合并计算上就不行了，因为调用compute的线程并不是概念上的调用方，后者是调用fork的那个。</p>
</li>
<li>
<p>和并行流一样，不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。一个任务可以分解成多个独立的子任务，才能让性能在并行化时有所提升。所有这些子任务的运行时间都应该比分出新任务所花的时间长；一个惯用方法是把输入/输出放在一个子任务里，计算放在另一个里，这样计算就可以和输入/输出同时进行。此外，在比较同一算法的顺序和并行版本的性能时还有别的因素要考虑。就像任何其他Java代码一样，分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。同时还要知道，编译器内置的优化可能会为顺序版本带来一些优势（例如执行代码分析——删去从未被使用的计算）</p>
</li>
</ul>
<h3 id="633-工作窃取">6.3.3 工作窃取</h3>
<p>应该让划分的子任务都用相同的时间完成，但是由于外部因素，如划分策略效率低、磁盘访问慢或是需要和外部服务协调执行，每个子任务所花的时间不尽相同。框架使用一种称为工作窃取（work stealing）的技术解决这个问题。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e5%b7%a5%e4%bd%9c%e7%aa%83%e5%8f%96.png"
        data-srcset="/images/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png, /images/Java/%e5%b7%a5%e4%bd%9c%e7%aa%83%e5%8f%96.png 1.5x, /images/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png 2x"
        data-sizes="auto"
        alt="/images/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png"
        title="工作窃取" /></p>
<h2 id="64-spliterator可分迭代器">6.4 Spliterator可分迭代器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">interace</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * 按序遍历，如果没有元素则返回false，否则对元素执行给定的操作并返回true
</span><span class="cm">     */</span>
    <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
    
    <span class="cm">/**
</span><span class="cm">     * 把元素划出去分给第二个Spliterator,让他们并行处理，直到返回null
</span><span class="cm">     */</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
    
     <span class="cm">/**
</span><span class="cm">     * 返回forEachRemaining遍历将遇到的估计值，如果无限或无法计算，则返回Long.MAX_VALUE
</span><span class="cm">     */</span>
    <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
    
    <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="641-拆分过程">6.4.1 拆分过程</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/spliterator%e8%bf%87%e7%a8%8b.png"
        data-srcset="/images/Java/spliterator%E8%BF%87%E7%A8%8B.png, /images/Java/spliterator%e8%bf%87%e7%a8%8b.png 1.5x, /images/Java/spliterator%E8%BF%87%E7%A8%8B.png 2x"
        data-sizes="auto"
        alt="/images/Java/spliterator%E8%BF%87%E7%A8%8B.png"
        title="spliterator过程" /></p>
<p><strong>Spliterator的特性</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ORDERED</td>
<td>元素有既定顺序，Spliterator在遍历和划分时遵循这一顺序</td>
</tr>
<tr>
<td>DISTINCT</td>
<td>对于任意一对遍历过的元素x和y，x.equals(y)返回false</td>
</tr>
<tr>
<td>SORTED</td>
<td>遍历的元素按照一个预定义的顺序排序</td>
</tr>
<tr>
<td>SIZED</td>
<td>该Spliterator由一个已知大小的源建立，因此estimatedSize()返回的是准确值</td>
</tr>
<tr>
<td>NONNULL</td>
<td>保证遍历的元素不会为null</td>
</tr>
<tr>
<td>IMMUTABLE</td>
<td>数据源不能修改</td>
</tr>
<tr>
<td>CONCURRENT</td>
<td>数据源可被其他线程同时修改而无需同步</td>
</tr>
<tr>
<td>SUBSIZED</td>
<td>所有拆分出来的Spliterator都是SIZED</td>
</tr>
</tbody>
</table>
<h3 id="642-自定义spliterator">6.4.2 自定义Spliterator</h3>
<h1 id="7-重构测试和调试">7. 重构、测试和调试</h1>
<h2 id="71-重构">7.1 重构</h2>
<h3 id="711-使用lambda替换匿名类">7.1.1 使用Lambda替换匿名类</h3>
<p>需要注意的是，Lambda中的this和super代表的是包含类，而匿名类的代表匿名类自身；匿名类可以屏蔽包含类的变量，而Lambda不能。另外，在涉及重载的上下文中，应该使用显示的类型转换来减低类型推断的难度。</p>
<h3 id="712-方法引用代替lambda">7.1.2 方法引用代替Lambda</h3>
<h3 id="713-从命令式的数据处理切换到stream">7.1.3 从命令式的数据处理切换到Stream</h3>
<h3 id="714重构模式">7.1.4重构模式</h3>
<p><strong>有条件的延迟执行</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isLoggable</span><span class="o">(</span><span class="n">Log</span><span class="o">.</span><span class="na">FINER</span><span class="o">)){</span>
	<span class="n">logger</span><span class="o">.</span><span class="na">finer</span><span class="o">(</span><span class="s">&#34;Problem: &#34;</span> <span class="o">+</span> <span class="n">generateDiagnostic</span><span class="o">());</span>
<span class="o">}</span>
<span class="c1">//使用log方法代替上面的判断
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="n">Level</span> <span class="n">level</span><span class="o">,</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">msgSupplier</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要频繁地从客户端去查询一个对象的状态（比如日志器的状态），只是为了传递参数、调用该对象的一个方法（比如输出一条日志），那么可以考虑实现一个新的方法，以Lambda或者方法表达式作为参数，代码会更易读，封装性会更好（对象的状态也不会暴露给客户端代码了）。</p>
<p><strong>环绕执行</strong></p>
<p>Lambda作为参数传递，类似切面。</p>
<h2 id="72-使用lambda重构面向对象的设计模式">7.2 使用Lambda重构面向对象的设计模式</h2>
<h3 id="721-策略模式">7.2.1 策略模式</h3>
<p>关键点：实现函数式接口</p>
<h3 id="722-模板方法">7.2.2 模板方法</h3>
<p>关键点：方法增加函数式入参</p>
<h3 id="723-观察者模式">7.2.3 观察者模式</h3>
<p>关键点：Lambda代替通知方法，注意如果观察者的逻辑十分复杂，比如它们可能持有状态亦或是定义了多个方法等，则应继续使用类的方式。</p>
<h3 id="724-责任链模式">7.2.4 责任链模式</h3>
<p>关键点：<code>UnaryOperator</code>、<code>andThen</code></p>
<h3 id="725-工厂模式">7.2.5 工厂模式</h3>
<p>关键点：构造函数入参低于2个时，使用方法引用&hellip;</p>
<h2 id="72-测试lambda">7.2 测试Lambda</h2>
<h2 id="73-调试">7.3 调试</h2>
<p>peek方法？</p>
<h1 id="8默认方法">8.默认方法</h1>
<p><strong>不同类型兼容性：二进制、源代码、和函数行为</strong></p>
<ul>
<li>二进制兼容：现有的二进制执行文件能无缝链（包括验证、准备和解析）和运行。比如，为接口添加一个方法就是二进制兼容的，这种方式下，如果新加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。</li>
<li>源代码兼容：引入变化后，现有的程序依然能成功编译通过。</li>
<li>函数行为兼容：变更后，程序接受同样的输入能得到同样的结果。</li>
</ul>
<p><strong>解决菱形继承的三条规则</strong></p>
<ul>
<li>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级</li>
<li>如果第一条无法判断，那么子接口的优先级更高。函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li>
<li>如果还是无法判断，继承了多个接口的类必须通过显示覆盖和调用期望的方法</li>
</ul>
<p>Java8引入了一种新语法<code>X.super.m(...)</code>，其中X是希望调用的m方法所在的父接口。</p>
<h1 id="9optional">9.Optional</h1>
<p>使用Optional的语义在于：可以很清楚地知道它可以接受空值，或者它可能返回一个空值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(...);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(...);</span>
<span class="c1">//如果要处理的元素为空，则不做任何操作,并返回一个空的Optional对象
</span><span class="c1"></span><span class="n">Optional</span><span class="o">.</span><span class="na">map</span><span class="o">(...);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(...);</span>

</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Optional不能被序列化。Java语言的架构师明确地说过它的设计初衷仅仅是要支持能返回Optional对象的语法。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Optional</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="n">T</span> <span class="n">other</span><span class="o">);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">orElseGet</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">X</span><span class="o">&gt;</span> <span class="n">exceptionSupplier</span><span class="o">);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;);</span>
<span class="n">Optional</span><span class="o">.</span><span class="na">isPresent</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="10completablefuture组合式异步编程">10.CompletableFuture组合式异步编程</h1>
<p>相比于并行流，CompletableFuture的优势在于可以配置线程池中的线程大小。</p>
<ul>
<li>如果进行的是计算密集型的操作，并且没有I/O，推荐使用Stream接口。</li>
<li>如果并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好。</li>
</ul>
<h1 id="11新的日期api">11.新的日期API</h1>
<h2 id="111-localdate和localtime">11.1 LocalDate和LocalTime</h2>
<h2 id="112-instant">11.2 Instant</h2>
<p>为了便于机器使用而设计</p>
<h2 id="113-duration或period">11.3 Duration或Period</h2>
<p>Duration主要用于以秒和纳秒衡量时间的长短；Period可以以年、月或日的方式对多个时间单位建模。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>是否静态方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>between</td>
<td>是</td>
<td>创建两个时间点之间的 interval  (间隔)</td>
</tr>
<tr>
<td>from</td>
<td>是</td>
<td>由一个临时时间点创建 interval</td>
</tr>
<tr>
<td>of</td>
<td>是</td>
<td>由它的组成部分创建 interval 的实例</td>
</tr>
<tr>
<td>parse</td>
<td>是</td>
<td>由字符串创建 interval 的实例</td>
</tr>
<tr>
<td>addTo</td>
<td>否</td>
<td>创建该 interval 的副本，并将其Ԯ加到某个指定的 temporal 对象</td>
</tr>
<tr>
<td>get</td>
<td>否</td>
<td>读取该 interval 的状态</td>
</tr>
<tr>
<td>isNegative</td>
<td>否</td>
<td>检查该 interval 是否为负值，不包含零</td>
</tr>
<tr>
<td>isZero</td>
<td>否</td>
<td>检查该 interval 的时长是否为零</td>
</tr>
<tr>
<td>minus</td>
<td>否</td>
<td>通过减去一定的时间创建该 interval 的副本</td>
</tr>
<tr>
<td>multipliedBy</td>
<td>否</td>
<td>将 interval 的值乘以某个标量创建该 interval 的副本</td>
</tr>
<tr>
<td>negated</td>
<td>否</td>
<td>以忽略某个时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>plus</td>
<td>否</td>
<td>以增加某个指定的时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>subtractFrom</td>
<td>否</td>
<td>从指定的 temporal 对象中减去该 interval</td>
</tr>
</tbody>
</table>
<h2 id="114-操纵解析和格式化日期">11.4 操纵、解析和格式化日期</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">withYear</span><span class="o">(</span><span class="n">2011</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">withDayOfMonth</span><span class="o">(</span><span class="n">25</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date4</span> <span class="o">=</span> <span class="n">date3</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">,</span> <span class="n">9</span><span class="o">);</span>

<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">plusWeeks</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">minusYears</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date4</span> <span class="o">=</span> <span class="n">date3</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">6</span><span class="o">,</span> <span class="n">ChronoUnit</span><span class="o">.</span><span class="na">MONTHS</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>方法名</th>
<th>是否静态方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td>是</td>
<td>依据传入的 Temporal 对象创建对象实例</td>
</tr>
<tr>
<td>now</td>
<td>是</td>
<td>依据系统时钟创建 Temporal 对象</td>
</tr>
<tr>
<td>of</td>
<td>是</td>
<td>由 Temporal 对象的某个部分创建该对象的实例</td>
</tr>
<tr>
<td>parse</td>
<td>是</td>
<td>由字符串创建 Temporal 对象的实例</td>
</tr>
<tr>
<td>atOffset</td>
<td>否</td>
<td>将 Temporal 对象和某个时区偏移相结合</td>
</tr>
<tr>
<td>atZone</td>
<td>否</td>
<td>将 Temporal 对象和某个时区相结合</td>
</tr>
<tr>
<td>format</td>
<td>否</td>
<td>使用某个指定的格式器将Temporal对象转换为字符串（ Instant类不提供该方法）</td>
</tr>
<tr>
<td>get</td>
<td>否</td>
<td>读取 Temporal 对象的某一部分的值</td>
</tr>
<tr>
<td>minus</td>
<td>否</td>
<td>创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值ђ去一定的时长，创建该副本</td>
</tr>
<tr>
<td>plus</td>
<td>否</td>
<td>创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值加上一定的时长，创建该副本</td>
</tr>
<tr>
<td>with</td>
<td>否</td>
<td>以该 Temporal 对象为模板，对某些状态进行修改创建该对象的副本</td>
</tr>
</tbody>
</table>
<h3 id="1141-使用temporaladjuster">11.4.1 使用TemporalAdjuster</h3>
<p>可以使用重载版本的with方法，向其传递一个提供了更多定制化选择的TemporalAdjuster对象，更 加 灵 活 地 处 理 日 期 。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e6%97%a5%e6%9c%9f.png"
        data-srcset="/images/Java/%E6%97%A5%E6%9C%9F.png, /images/Java/%e6%97%a5%e6%9c%9f.png 1.5x, /images/Java/%E6%97%A5%E6%9C%9F.png 2x"
        data-sizes="auto"
        alt="/images/Java/%E6%97%A5%E6%9C%9F.png"
        title="日期" /></p>
<hr>
<h3 id="1142-datetimeformatter">11.4.2 DateTimeFormatter</h3>
<p>线程安全的，内置了几种解析常量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span> <span class="c1">// 20140318
</span><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;20140318&#34;</span><span class="o">,</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">,</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span>

<span class="n">DateTimeFormatter</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;dd/MM/yyyy&#34;</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">formattedDate</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">formatter</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">formattedDate</span><span class="o">,</span> <span class="n">formatter</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>创建一个本地化的DateTimeFormatter</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;d. MMMM yyyy&#34;</span><span class="o">,</span> <span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">formattedDate</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">italianFormatter</span><span class="o">);</span> <span class="c1">// 18. marzo 2014
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">formattedDate</span><span class="o">,</span> <span class="n">italianFormatter</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果需要更加细粒度的控制， DateTimeFormatterBuilder类还提供了更复杂的格式器，可以选择恰当的方法，一步一步地构造自己的格式器。另外，它还提供了非常强大的解析功能，比如区分大小写的解析、柔性解析（允许解析器使用启发式的机制去解析输入，不精 确 地 匹 配 指 定 的 模 式 ）、 填充 ， 以 及 在 格 式 器 中 指 定 可 选 节 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DateTimeFormatterBuilder</span><span class="o">()</span>
<span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">)</span>
<span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34;. &#34;</span><span class="o">)</span>
<span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">)</span>
<span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span>
<span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">)</span>
<span class="o">.</span><span class="na">parseCaseInsensitive</span><span class="o">()</span>
<span class="o">.</span><span class="na">toFormatter</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="115-处理不同的时区和历法">11.5 处理不同的时区和历法</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/Java/%e6%97%b6%e5%8c%ba.png"
        data-srcset="/images/Java/%E6%97%B6%E5%8C%BA.png, /images/Java/%e6%97%b6%e5%8c%ba.png 1.5x, /images/Java/%E6%97%B6%E5%8C%BA.png 2x"
        data-sizes="auto"
        alt="/images/Java/%E6%97%B6%E5%8C%BA.png"
        title="时区" /></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2025-04-16</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/java8%E5%AE%9E%E6%88%98/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/java%E6%B3%9B%E5%9E%8B/" class="prev" rel="prev" title="Java中的泛型"><i class="fas fa-angle-left fa-fw"></i>Java中的泛型</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">H2oLo</div><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.92.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022 - 2025</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/" target="_blank">湘ICP备19007912号</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"H2oLo","id-2":"H2oLo"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
